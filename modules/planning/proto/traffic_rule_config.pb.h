// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/planning/proto/traffic_rule_config.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
namespace apollo {
namespace planning {
class BacksideVehicleConfig;
class BacksideVehicleConfigDefaultTypeInternal;
extern BacksideVehicleConfigDefaultTypeInternal _BacksideVehicleConfig_default_instance_;
class CrosswalkConfig;
class CrosswalkConfigDefaultTypeInternal;
extern CrosswalkConfigDefaultTypeInternal _CrosswalkConfig_default_instance_;
class DestinationConfig;
class DestinationConfigDefaultTypeInternal;
extern DestinationConfigDefaultTypeInternal _DestinationConfig_default_instance_;
class KeepClearConfig;
class KeepClearConfigDefaultTypeInternal;
extern KeepClearConfigDefaultTypeInternal _KeepClearConfig_default_instance_;
class ReferenceLineEndConfig;
class ReferenceLineEndConfigDefaultTypeInternal;
extern ReferenceLineEndConfigDefaultTypeInternal _ReferenceLineEndConfig_default_instance_;
class ReroutingConfig;
class ReroutingConfigDefaultTypeInternal;
extern ReroutingConfigDefaultTypeInternal _ReroutingConfig_default_instance_;
class StopSignConfig;
class StopSignConfigDefaultTypeInternal;
extern StopSignConfigDefaultTypeInternal _StopSignConfig_default_instance_;
class TrafficLightConfig;
class TrafficLightConfigDefaultTypeInternal;
extern TrafficLightConfigDefaultTypeInternal _TrafficLightConfig_default_instance_;
class TrafficRuleConfig;
class TrafficRuleConfigDefaultTypeInternal;
extern TrafficRuleConfigDefaultTypeInternal _TrafficRuleConfig_default_instance_;
class TrafficRuleConfigs;
class TrafficRuleConfigsDefaultTypeInternal;
extern TrafficRuleConfigsDefaultTypeInternal _TrafficRuleConfigs_default_instance_;
class YieldSignConfig;
class YieldSignConfigDefaultTypeInternal;
extern YieldSignConfigDefaultTypeInternal _YieldSignConfig_default_instance_;
}  // namespace planning
}  // namespace apollo
PROTOBUF_NAMESPACE_OPEN
template<> ::apollo::planning::BacksideVehicleConfig* Arena::CreateMaybeMessage<::apollo::planning::BacksideVehicleConfig>(Arena*);
template<> ::apollo::planning::CrosswalkConfig* Arena::CreateMaybeMessage<::apollo::planning::CrosswalkConfig>(Arena*);
template<> ::apollo::planning::DestinationConfig* Arena::CreateMaybeMessage<::apollo::planning::DestinationConfig>(Arena*);
template<> ::apollo::planning::KeepClearConfig* Arena::CreateMaybeMessage<::apollo::planning::KeepClearConfig>(Arena*);
template<> ::apollo::planning::ReferenceLineEndConfig* Arena::CreateMaybeMessage<::apollo::planning::ReferenceLineEndConfig>(Arena*);
template<> ::apollo::planning::ReroutingConfig* Arena::CreateMaybeMessage<::apollo::planning::ReroutingConfig>(Arena*);
template<> ::apollo::planning::StopSignConfig* Arena::CreateMaybeMessage<::apollo::planning::StopSignConfig>(Arena*);
template<> ::apollo::planning::TrafficLightConfig* Arena::CreateMaybeMessage<::apollo::planning::TrafficLightConfig>(Arena*);
template<> ::apollo::planning::TrafficRuleConfig* Arena::CreateMaybeMessage<::apollo::planning::TrafficRuleConfig>(Arena*);
template<> ::apollo::planning::TrafficRuleConfigs* Arena::CreateMaybeMessage<::apollo::planning::TrafficRuleConfigs>(Arena*);
template<> ::apollo::planning::YieldSignConfig* Arena::CreateMaybeMessage<::apollo::planning::YieldSignConfig>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace apollo {
namespace planning {

enum TrafficRuleConfig_RuleId : int {
  TrafficRuleConfig_RuleId_BACKSIDE_VEHICLE = 1,
  TrafficRuleConfig_RuleId_CROSSWALK = 2,
  TrafficRuleConfig_RuleId_DESTINATION = 3,
  TrafficRuleConfig_RuleId_KEEP_CLEAR = 4,
  TrafficRuleConfig_RuleId_REFERENCE_LINE_END = 5,
  TrafficRuleConfig_RuleId_REROUTING = 6,
  TrafficRuleConfig_RuleId_STOP_SIGN = 7,
  TrafficRuleConfig_RuleId_TRAFFIC_LIGHT = 8,
  TrafficRuleConfig_RuleId_YIELD_SIGN = 9
};
bool TrafficRuleConfig_RuleId_IsValid(int value);
constexpr TrafficRuleConfig_RuleId TrafficRuleConfig_RuleId_RuleId_MIN = TrafficRuleConfig_RuleId_BACKSIDE_VEHICLE;
constexpr TrafficRuleConfig_RuleId TrafficRuleConfig_RuleId_RuleId_MAX = TrafficRuleConfig_RuleId_YIELD_SIGN;
constexpr int TrafficRuleConfig_RuleId_RuleId_ARRAYSIZE = TrafficRuleConfig_RuleId_RuleId_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TrafficRuleConfig_RuleId_descriptor();
template<typename T>
inline const std::string& TrafficRuleConfig_RuleId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TrafficRuleConfig_RuleId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TrafficRuleConfig_RuleId_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TrafficRuleConfig_RuleId_descriptor(), enum_t_value);
}
inline bool TrafficRuleConfig_RuleId_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TrafficRuleConfig_RuleId* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TrafficRuleConfig_RuleId>(
    TrafficRuleConfig_RuleId_descriptor(), name, value);
}
// ===================================================================

class BacksideVehicleConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.BacksideVehicleConfig) */ {
 public:
  inline BacksideVehicleConfig() : BacksideVehicleConfig(nullptr) {}
  virtual ~BacksideVehicleConfig();

  BacksideVehicleConfig(const BacksideVehicleConfig& from);
  BacksideVehicleConfig(BacksideVehicleConfig&& from) noexcept
    : BacksideVehicleConfig() {
    *this = ::std::move(from);
  }

  inline BacksideVehicleConfig& operator=(const BacksideVehicleConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline BacksideVehicleConfig& operator=(BacksideVehicleConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BacksideVehicleConfig& default_instance();

  static inline const BacksideVehicleConfig* internal_default_instance() {
    return reinterpret_cast<const BacksideVehicleConfig*>(
               &_BacksideVehicleConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(BacksideVehicleConfig& a, BacksideVehicleConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(BacksideVehicleConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BacksideVehicleConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BacksideVehicleConfig* New() const final {
    return CreateMaybeMessage<BacksideVehicleConfig>(nullptr);
  }

  BacksideVehicleConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BacksideVehicleConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BacksideVehicleConfig& from);
  void MergeFrom(const BacksideVehicleConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BacksideVehicleConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.BacksideVehicleConfig";
  }
  protected:
  explicit BacksideVehicleConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBacksideLaneWidthFieldNumber = 1,
  };
  // optional double backside_lane_width = 1 [default = 4];
  bool has_backside_lane_width() const;
  private:
  bool _internal_has_backside_lane_width() const;
  public:
  void clear_backside_lane_width();
  double backside_lane_width() const;
  void set_backside_lane_width(double value);
  private:
  double _internal_backside_lane_width() const;
  void _internal_set_backside_lane_width(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.BacksideVehicleConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double backside_lane_width_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class CrosswalkConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.CrosswalkConfig) */ {
 public:
  inline CrosswalkConfig() : CrosswalkConfig(nullptr) {}
  virtual ~CrosswalkConfig();

  CrosswalkConfig(const CrosswalkConfig& from);
  CrosswalkConfig(CrosswalkConfig&& from) noexcept
    : CrosswalkConfig() {
    *this = ::std::move(from);
  }

  inline CrosswalkConfig& operator=(const CrosswalkConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline CrosswalkConfig& operator=(CrosswalkConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CrosswalkConfig& default_instance();

  static inline const CrosswalkConfig* internal_default_instance() {
    return reinterpret_cast<const CrosswalkConfig*>(
               &_CrosswalkConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CrosswalkConfig& a, CrosswalkConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(CrosswalkConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CrosswalkConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CrosswalkConfig* New() const final {
    return CreateMaybeMessage<CrosswalkConfig>(nullptr);
  }

  CrosswalkConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CrosswalkConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CrosswalkConfig& from);
  void MergeFrom(const CrosswalkConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CrosswalkConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.CrosswalkConfig";
  }
  protected:
  explicit CrosswalkConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStopDistanceFieldNumber = 1,
    kMaxStopDecelerationFieldNumber = 2,
    kMinPassSDistanceFieldNumber = 3,
    kMaxValidStopDistanceFieldNumber = 4,
    kExpandSDistanceFieldNumber = 5,
    kStopStrictLDistanceFieldNumber = 6,
    kStopLooseLDistanceFieldNumber = 7,
    kStopTimeoutFieldNumber = 8,
  };
  // optional double stop_distance = 1 [default = 1];
  bool has_stop_distance() const;
  private:
  bool _internal_has_stop_distance() const;
  public:
  void clear_stop_distance();
  double stop_distance() const;
  void set_stop_distance(double value);
  private:
  double _internal_stop_distance() const;
  void _internal_set_stop_distance(double value);
  public:

  // optional double max_stop_deceleration = 2 [default = 4];
  bool has_max_stop_deceleration() const;
  private:
  bool _internal_has_max_stop_deceleration() const;
  public:
  void clear_max_stop_deceleration();
  double max_stop_deceleration() const;
  void set_max_stop_deceleration(double value);
  private:
  double _internal_max_stop_deceleration() const;
  void _internal_set_max_stop_deceleration(double value);
  public:

  // optional double min_pass_s_distance = 3 [default = 1];
  bool has_min_pass_s_distance() const;
  private:
  bool _internal_has_min_pass_s_distance() const;
  public:
  void clear_min_pass_s_distance();
  double min_pass_s_distance() const;
  void set_min_pass_s_distance(double value);
  private:
  double _internal_min_pass_s_distance() const;
  void _internal_set_min_pass_s_distance(double value);
  public:

  // optional double max_valid_stop_distance = 4 [default = 3];
  bool has_max_valid_stop_distance() const;
  private:
  bool _internal_has_max_valid_stop_distance() const;
  public:
  void clear_max_valid_stop_distance();
  double max_valid_stop_distance() const;
  void set_max_valid_stop_distance(double value);
  private:
  double _internal_max_valid_stop_distance() const;
  void _internal_set_max_valid_stop_distance(double value);
  public:

  // optional double expand_s_distance = 5 [default = 2];
  bool has_expand_s_distance() const;
  private:
  bool _internal_has_expand_s_distance() const;
  public:
  void clear_expand_s_distance();
  double expand_s_distance() const;
  void set_expand_s_distance(double value);
  private:
  double _internal_expand_s_distance() const;
  void _internal_set_expand_s_distance(double value);
  public:

  // optional double stop_strict_l_distance = 6 [default = 4];
  bool has_stop_strict_l_distance() const;
  private:
  bool _internal_has_stop_strict_l_distance() const;
  public:
  void clear_stop_strict_l_distance();
  double stop_strict_l_distance() const;
  void set_stop_strict_l_distance(double value);
  private:
  double _internal_stop_strict_l_distance() const;
  void _internal_set_stop_strict_l_distance(double value);
  public:

  // optional double stop_loose_l_distance = 7 [default = 5];
  bool has_stop_loose_l_distance() const;
  private:
  bool _internal_has_stop_loose_l_distance() const;
  public:
  void clear_stop_loose_l_distance();
  double stop_loose_l_distance() const;
  void set_stop_loose_l_distance(double value);
  private:
  double _internal_stop_loose_l_distance() const;
  void _internal_set_stop_loose_l_distance(double value);
  public:

  // optional double stop_timeout = 8 [default = 10];
  bool has_stop_timeout() const;
  private:
  bool _internal_has_stop_timeout() const;
  public:
  void clear_stop_timeout();
  double stop_timeout() const;
  void set_stop_timeout(double value);
  private:
  double _internal_stop_timeout() const;
  void _internal_set_stop_timeout(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.CrosswalkConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double stop_distance_;
  double max_stop_deceleration_;
  double min_pass_s_distance_;
  double max_valid_stop_distance_;
  double expand_s_distance_;
  double stop_strict_l_distance_;
  double stop_loose_l_distance_;
  double stop_timeout_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class DestinationConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.DestinationConfig) */ {
 public:
  inline DestinationConfig() : DestinationConfig(nullptr) {}
  virtual ~DestinationConfig();

  DestinationConfig(const DestinationConfig& from);
  DestinationConfig(DestinationConfig&& from) noexcept
    : DestinationConfig() {
    *this = ::std::move(from);
  }

  inline DestinationConfig& operator=(const DestinationConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline DestinationConfig& operator=(DestinationConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DestinationConfig& default_instance();

  static inline const DestinationConfig* internal_default_instance() {
    return reinterpret_cast<const DestinationConfig*>(
               &_DestinationConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DestinationConfig& a, DestinationConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(DestinationConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DestinationConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DestinationConfig* New() const final {
    return CreateMaybeMessage<DestinationConfig>(nullptr);
  }

  DestinationConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DestinationConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DestinationConfig& from);
  void MergeFrom(const DestinationConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DestinationConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.DestinationConfig";
  }
  protected:
  explicit DestinationConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStopDistanceFieldNumber = 1,
  };
  // optional double stop_distance = 1 [default = 0.5];
  bool has_stop_distance() const;
  private:
  bool _internal_has_stop_distance() const;
  public:
  void clear_stop_distance();
  double stop_distance() const;
  void set_stop_distance(double value);
  private:
  double _internal_stop_distance() const;
  void _internal_set_stop_distance(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.DestinationConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double stop_distance_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class KeepClearConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.KeepClearConfig) */ {
 public:
  inline KeepClearConfig() : KeepClearConfig(nullptr) {}
  virtual ~KeepClearConfig();

  KeepClearConfig(const KeepClearConfig& from);
  KeepClearConfig(KeepClearConfig&& from) noexcept
    : KeepClearConfig() {
    *this = ::std::move(from);
  }

  inline KeepClearConfig& operator=(const KeepClearConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeepClearConfig& operator=(KeepClearConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const KeepClearConfig& default_instance();

  static inline const KeepClearConfig* internal_default_instance() {
    return reinterpret_cast<const KeepClearConfig*>(
               &_KeepClearConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(KeepClearConfig& a, KeepClearConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(KeepClearConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeepClearConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KeepClearConfig* New() const final {
    return CreateMaybeMessage<KeepClearConfig>(nullptr);
  }

  KeepClearConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KeepClearConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const KeepClearConfig& from);
  void MergeFrom(const KeepClearConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeepClearConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.KeepClearConfig";
  }
  protected:
  explicit KeepClearConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnableKeepClearZoneFieldNumber = 1,
    kEnableJunctionFieldNumber = 2,
    kMinPassSDistanceFieldNumber = 3,
    kAlignWithTrafficSignToleranceFieldNumber = 4,
  };
  // optional bool enable_keep_clear_zone = 1 [default = true];
  bool has_enable_keep_clear_zone() const;
  private:
  bool _internal_has_enable_keep_clear_zone() const;
  public:
  void clear_enable_keep_clear_zone();
  bool enable_keep_clear_zone() const;
  void set_enable_keep_clear_zone(bool value);
  private:
  bool _internal_enable_keep_clear_zone() const;
  void _internal_set_enable_keep_clear_zone(bool value);
  public:

  // optional bool enable_junction = 2 [default = true];
  bool has_enable_junction() const;
  private:
  bool _internal_has_enable_junction() const;
  public:
  void clear_enable_junction();
  bool enable_junction() const;
  void set_enable_junction(bool value);
  private:
  bool _internal_enable_junction() const;
  void _internal_set_enable_junction(bool value);
  public:

  // optional double min_pass_s_distance = 3 [default = 2];
  bool has_min_pass_s_distance() const;
  private:
  bool _internal_has_min_pass_s_distance() const;
  public:
  void clear_min_pass_s_distance();
  double min_pass_s_distance() const;
  void set_min_pass_s_distance(double value);
  private:
  double _internal_min_pass_s_distance() const;
  void _internal_set_min_pass_s_distance(double value);
  public:

  // optional double align_with_traffic_sign_tolerance = 4 [default = 4.5];
  bool has_align_with_traffic_sign_tolerance() const;
  private:
  bool _internal_has_align_with_traffic_sign_tolerance() const;
  public:
  void clear_align_with_traffic_sign_tolerance();
  double align_with_traffic_sign_tolerance() const;
  void set_align_with_traffic_sign_tolerance(double value);
  private:
  double _internal_align_with_traffic_sign_tolerance() const;
  void _internal_set_align_with_traffic_sign_tolerance(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.KeepClearConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool enable_keep_clear_zone_;
  bool enable_junction_;
  double min_pass_s_distance_;
  double align_with_traffic_sign_tolerance_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ReferenceLineEndConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ReferenceLineEndConfig) */ {
 public:
  inline ReferenceLineEndConfig() : ReferenceLineEndConfig(nullptr) {}
  virtual ~ReferenceLineEndConfig();

  ReferenceLineEndConfig(const ReferenceLineEndConfig& from);
  ReferenceLineEndConfig(ReferenceLineEndConfig&& from) noexcept
    : ReferenceLineEndConfig() {
    *this = ::std::move(from);
  }

  inline ReferenceLineEndConfig& operator=(const ReferenceLineEndConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReferenceLineEndConfig& operator=(ReferenceLineEndConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReferenceLineEndConfig& default_instance();

  static inline const ReferenceLineEndConfig* internal_default_instance() {
    return reinterpret_cast<const ReferenceLineEndConfig*>(
               &_ReferenceLineEndConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ReferenceLineEndConfig& a, ReferenceLineEndConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ReferenceLineEndConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReferenceLineEndConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReferenceLineEndConfig* New() const final {
    return CreateMaybeMessage<ReferenceLineEndConfig>(nullptr);
  }

  ReferenceLineEndConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReferenceLineEndConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReferenceLineEndConfig& from);
  void MergeFrom(const ReferenceLineEndConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReferenceLineEndConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.ReferenceLineEndConfig";
  }
  protected:
  explicit ReferenceLineEndConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStopDistanceFieldNumber = 1,
    kMinReferenceLineRemainLengthFieldNumber = 2,
  };
  // optional double stop_distance = 1 [default = 0.5];
  bool has_stop_distance() const;
  private:
  bool _internal_has_stop_distance() const;
  public:
  void clear_stop_distance();
  double stop_distance() const;
  void set_stop_distance(double value);
  private:
  double _internal_stop_distance() const;
  void _internal_set_stop_distance(double value);
  public:

  // optional double min_reference_line_remain_length = 2 [default = 50];
  bool has_min_reference_line_remain_length() const;
  private:
  bool _internal_has_min_reference_line_remain_length() const;
  public:
  void clear_min_reference_line_remain_length();
  double min_reference_line_remain_length() const;
  void set_min_reference_line_remain_length(double value);
  private:
  double _internal_min_reference_line_remain_length() const;
  void _internal_set_min_reference_line_remain_length(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.ReferenceLineEndConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double stop_distance_;
  double min_reference_line_remain_length_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class ReroutingConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ReroutingConfig) */ {
 public:
  inline ReroutingConfig() : ReroutingConfig(nullptr) {}
  virtual ~ReroutingConfig();

  ReroutingConfig(const ReroutingConfig& from);
  ReroutingConfig(ReroutingConfig&& from) noexcept
    : ReroutingConfig() {
    *this = ::std::move(from);
  }

  inline ReroutingConfig& operator=(const ReroutingConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReroutingConfig& operator=(ReroutingConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReroutingConfig& default_instance();

  static inline const ReroutingConfig* internal_default_instance() {
    return reinterpret_cast<const ReroutingConfig*>(
               &_ReroutingConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ReroutingConfig& a, ReroutingConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ReroutingConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReroutingConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReroutingConfig* New() const final {
    return CreateMaybeMessage<ReroutingConfig>(nullptr);
  }

  ReroutingConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReroutingConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReroutingConfig& from);
  void MergeFrom(const ReroutingConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReroutingConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.ReroutingConfig";
  }
  protected:
  explicit ReroutingConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCooldownTimeFieldNumber = 1,
    kPrepareReroutingTimeFieldNumber = 2,
  };
  // optional double cooldown_time = 1 [default = 3];
  bool has_cooldown_time() const;
  private:
  bool _internal_has_cooldown_time() const;
  public:
  void clear_cooldown_time();
  double cooldown_time() const;
  void set_cooldown_time(double value);
  private:
  double _internal_cooldown_time() const;
  void _internal_set_cooldown_time(double value);
  public:

  // optional double prepare_rerouting_time = 2 [default = 2];
  bool has_prepare_rerouting_time() const;
  private:
  bool _internal_has_prepare_rerouting_time() const;
  public:
  void clear_prepare_rerouting_time();
  double prepare_rerouting_time() const;
  void set_prepare_rerouting_time(double value);
  private:
  double _internal_prepare_rerouting_time() const;
  void _internal_set_prepare_rerouting_time(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.ReroutingConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double cooldown_time_;
  double prepare_rerouting_time_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class StopSignConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.StopSignConfig) */ {
 public:
  inline StopSignConfig() : StopSignConfig(nullptr) {}
  virtual ~StopSignConfig();

  StopSignConfig(const StopSignConfig& from);
  StopSignConfig(StopSignConfig&& from) noexcept
    : StopSignConfig() {
    *this = ::std::move(from);
  }

  inline StopSignConfig& operator=(const StopSignConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopSignConfig& operator=(StopSignConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StopSignConfig& default_instance();

  static inline const StopSignConfig* internal_default_instance() {
    return reinterpret_cast<const StopSignConfig*>(
               &_StopSignConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(StopSignConfig& a, StopSignConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(StopSignConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopSignConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StopSignConfig* New() const final {
    return CreateMaybeMessage<StopSignConfig>(nullptr);
  }

  StopSignConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StopSignConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StopSignConfig& from);
  void MergeFrom(const StopSignConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopSignConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.StopSignConfig";
  }
  protected:
  explicit StopSignConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
    kStopDistanceFieldNumber = 2,
  };
  // optional bool enabled = 1 [default = true];
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // optional double stop_distance = 2 [default = 1];
  bool has_stop_distance() const;
  private:
  bool _internal_has_stop_distance() const;
  public:
  void clear_stop_distance();
  double stop_distance() const;
  void set_stop_distance(double value);
  private:
  double _internal_stop_distance() const;
  void _internal_set_stop_distance(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.StopSignConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool enabled_;
  double stop_distance_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class TrafficLightConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.TrafficLightConfig) */ {
 public:
  inline TrafficLightConfig() : TrafficLightConfig(nullptr) {}
  virtual ~TrafficLightConfig();

  TrafficLightConfig(const TrafficLightConfig& from);
  TrafficLightConfig(TrafficLightConfig&& from) noexcept
    : TrafficLightConfig() {
    *this = ::std::move(from);
  }

  inline TrafficLightConfig& operator=(const TrafficLightConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficLightConfig& operator=(TrafficLightConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TrafficLightConfig& default_instance();

  static inline const TrafficLightConfig* internal_default_instance() {
    return reinterpret_cast<const TrafficLightConfig*>(
               &_TrafficLightConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TrafficLightConfig& a, TrafficLightConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficLightConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficLightConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TrafficLightConfig* New() const final {
    return CreateMaybeMessage<TrafficLightConfig>(nullptr);
  }

  TrafficLightConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TrafficLightConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TrafficLightConfig& from);
  void MergeFrom(const TrafficLightConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficLightConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.TrafficLightConfig";
  }
  protected:
  explicit TrafficLightConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
    kStopDistanceFieldNumber = 2,
    kMaxStopDecelerationFieldNumber = 3,
  };
  // optional bool enabled = 1 [default = true];
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // optional double stop_distance = 2 [default = 1];
  bool has_stop_distance() const;
  private:
  bool _internal_has_stop_distance() const;
  public:
  void clear_stop_distance();
  double stop_distance() const;
  void set_stop_distance(double value);
  private:
  double _internal_stop_distance() const;
  void _internal_set_stop_distance(double value);
  public:

  // optional double max_stop_deceleration = 3 [default = 4];
  bool has_max_stop_deceleration() const;
  private:
  bool _internal_has_max_stop_deceleration() const;
  public:
  void clear_max_stop_deceleration();
  double max_stop_deceleration() const;
  void set_max_stop_deceleration(double value);
  private:
  double _internal_max_stop_deceleration() const;
  void _internal_set_max_stop_deceleration(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.TrafficLightConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool enabled_;
  double stop_distance_;
  double max_stop_deceleration_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class YieldSignConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.YieldSignConfig) */ {
 public:
  inline YieldSignConfig() : YieldSignConfig(nullptr) {}
  virtual ~YieldSignConfig();

  YieldSignConfig(const YieldSignConfig& from);
  YieldSignConfig(YieldSignConfig&& from) noexcept
    : YieldSignConfig() {
    *this = ::std::move(from);
  }

  inline YieldSignConfig& operator=(const YieldSignConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline YieldSignConfig& operator=(YieldSignConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const YieldSignConfig& default_instance();

  static inline const YieldSignConfig* internal_default_instance() {
    return reinterpret_cast<const YieldSignConfig*>(
               &_YieldSignConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(YieldSignConfig& a, YieldSignConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(YieldSignConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(YieldSignConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline YieldSignConfig* New() const final {
    return CreateMaybeMessage<YieldSignConfig>(nullptr);
  }

  YieldSignConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<YieldSignConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const YieldSignConfig& from);
  void MergeFrom(const YieldSignConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(YieldSignConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.YieldSignConfig";
  }
  protected:
  explicit YieldSignConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
    kStopDistanceFieldNumber = 2,
    kStartWatchDistanceFieldNumber = 3,
  };
  // optional bool enabled = 1 [default = true];
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // optional double stop_distance = 2 [default = 1];
  bool has_stop_distance() const;
  private:
  bool _internal_has_stop_distance() const;
  public:
  void clear_stop_distance();
  double stop_distance() const;
  void set_stop_distance(double value);
  private:
  double _internal_stop_distance() const;
  void _internal_set_stop_distance(double value);
  public:

  // optional double start_watch_distance = 3 [default = 2];
  bool has_start_watch_distance() const;
  private:
  bool _internal_has_start_watch_distance() const;
  public:
  void clear_start_watch_distance();
  double start_watch_distance() const;
  void set_start_watch_distance(double value);
  private:
  double _internal_start_watch_distance() const;
  void _internal_set_start_watch_distance(double value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.planning.YieldSignConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool enabled_;
  double stop_distance_;
  double start_watch_distance_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class TrafficRuleConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.TrafficRuleConfig) */ {
 public:
  inline TrafficRuleConfig() : TrafficRuleConfig(nullptr) {}
  virtual ~TrafficRuleConfig();

  TrafficRuleConfig(const TrafficRuleConfig& from);
  TrafficRuleConfig(TrafficRuleConfig&& from) noexcept
    : TrafficRuleConfig() {
    *this = ::std::move(from);
  }

  inline TrafficRuleConfig& operator=(const TrafficRuleConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficRuleConfig& operator=(TrafficRuleConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TrafficRuleConfig& default_instance();

  enum ConfigCase {
    kBacksideVehicle = 3,
    kCrosswalk = 4,
    kDestination = 5,
    kKeepClear = 6,
    kReferenceLineEnd = 7,
    kRerouting = 8,
    kStopSign = 9,
    kTrafficLight = 10,
    kYieldSign = 11,
    CONFIG_NOT_SET = 0,
  };

  static inline const TrafficRuleConfig* internal_default_instance() {
    return reinterpret_cast<const TrafficRuleConfig*>(
               &_TrafficRuleConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TrafficRuleConfig& a, TrafficRuleConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficRuleConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficRuleConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TrafficRuleConfig* New() const final {
    return CreateMaybeMessage<TrafficRuleConfig>(nullptr);
  }

  TrafficRuleConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TrafficRuleConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TrafficRuleConfig& from);
  void MergeFrom(const TrafficRuleConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficRuleConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.TrafficRuleConfig";
  }
  protected:
  explicit TrafficRuleConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TrafficRuleConfig_RuleId RuleId;
  static constexpr RuleId BACKSIDE_VEHICLE =
    TrafficRuleConfig_RuleId_BACKSIDE_VEHICLE;
  static constexpr RuleId CROSSWALK =
    TrafficRuleConfig_RuleId_CROSSWALK;
  static constexpr RuleId DESTINATION =
    TrafficRuleConfig_RuleId_DESTINATION;
  static constexpr RuleId KEEP_CLEAR =
    TrafficRuleConfig_RuleId_KEEP_CLEAR;
  static constexpr RuleId REFERENCE_LINE_END =
    TrafficRuleConfig_RuleId_REFERENCE_LINE_END;
  static constexpr RuleId REROUTING =
    TrafficRuleConfig_RuleId_REROUTING;
  static constexpr RuleId STOP_SIGN =
    TrafficRuleConfig_RuleId_STOP_SIGN;
  static constexpr RuleId TRAFFIC_LIGHT =
    TrafficRuleConfig_RuleId_TRAFFIC_LIGHT;
  static constexpr RuleId YIELD_SIGN =
    TrafficRuleConfig_RuleId_YIELD_SIGN;
  static inline bool RuleId_IsValid(int value) {
    return TrafficRuleConfig_RuleId_IsValid(value);
  }
  static constexpr RuleId RuleId_MIN =
    TrafficRuleConfig_RuleId_RuleId_MIN;
  static constexpr RuleId RuleId_MAX =
    TrafficRuleConfig_RuleId_RuleId_MAX;
  static constexpr int RuleId_ARRAYSIZE =
    TrafficRuleConfig_RuleId_RuleId_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RuleId_descriptor() {
    return TrafficRuleConfig_RuleId_descriptor();
  }
  template<typename T>
  static inline const std::string& RuleId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RuleId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RuleId_Name.");
    return TrafficRuleConfig_RuleId_Name(enum_t_value);
  }
  static inline bool RuleId_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RuleId* value) {
    return TrafficRuleConfig_RuleId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 2,
    kRuleIdFieldNumber = 1,
    kBacksideVehicleFieldNumber = 3,
    kCrosswalkFieldNumber = 4,
    kDestinationFieldNumber = 5,
    kKeepClearFieldNumber = 6,
    kReferenceLineEndFieldNumber = 7,
    kReroutingFieldNumber = 8,
    kStopSignFieldNumber = 9,
    kTrafficLightFieldNumber = 10,
    kYieldSignFieldNumber = 11,
  };
  // optional bool enabled = 2;
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // optional .apollo.planning.TrafficRuleConfig.RuleId rule_id = 1;
  bool has_rule_id() const;
  private:
  bool _internal_has_rule_id() const;
  public:
  void clear_rule_id();
  ::apollo::planning::TrafficRuleConfig_RuleId rule_id() const;
  void set_rule_id(::apollo::planning::TrafficRuleConfig_RuleId value);
  private:
  ::apollo::planning::TrafficRuleConfig_RuleId _internal_rule_id() const;
  void _internal_set_rule_id(::apollo::planning::TrafficRuleConfig_RuleId value);
  public:

  // .apollo.planning.BacksideVehicleConfig backside_vehicle = 3;
  bool has_backside_vehicle() const;
  private:
  bool _internal_has_backside_vehicle() const;
  public:
  void clear_backside_vehicle();
  const ::apollo::planning::BacksideVehicleConfig& backside_vehicle() const;
  ::apollo::planning::BacksideVehicleConfig* release_backside_vehicle();
  ::apollo::planning::BacksideVehicleConfig* mutable_backside_vehicle();
  void set_allocated_backside_vehicle(::apollo::planning::BacksideVehicleConfig* backside_vehicle);
  private:
  const ::apollo::planning::BacksideVehicleConfig& _internal_backside_vehicle() const;
  ::apollo::planning::BacksideVehicleConfig* _internal_mutable_backside_vehicle();
  public:
  void unsafe_arena_set_allocated_backside_vehicle(
      ::apollo::planning::BacksideVehicleConfig* backside_vehicle);
  ::apollo::planning::BacksideVehicleConfig* unsafe_arena_release_backside_vehicle();

  // .apollo.planning.CrosswalkConfig crosswalk = 4;
  bool has_crosswalk() const;
  private:
  bool _internal_has_crosswalk() const;
  public:
  void clear_crosswalk();
  const ::apollo::planning::CrosswalkConfig& crosswalk() const;
  ::apollo::planning::CrosswalkConfig* release_crosswalk();
  ::apollo::planning::CrosswalkConfig* mutable_crosswalk();
  void set_allocated_crosswalk(::apollo::planning::CrosswalkConfig* crosswalk);
  private:
  const ::apollo::planning::CrosswalkConfig& _internal_crosswalk() const;
  ::apollo::planning::CrosswalkConfig* _internal_mutable_crosswalk();
  public:
  void unsafe_arena_set_allocated_crosswalk(
      ::apollo::planning::CrosswalkConfig* crosswalk);
  ::apollo::planning::CrosswalkConfig* unsafe_arena_release_crosswalk();

  // .apollo.planning.DestinationConfig destination = 5;
  bool has_destination() const;
  private:
  bool _internal_has_destination() const;
  public:
  void clear_destination();
  const ::apollo::planning::DestinationConfig& destination() const;
  ::apollo::planning::DestinationConfig* release_destination();
  ::apollo::planning::DestinationConfig* mutable_destination();
  void set_allocated_destination(::apollo::planning::DestinationConfig* destination);
  private:
  const ::apollo::planning::DestinationConfig& _internal_destination() const;
  ::apollo::planning::DestinationConfig* _internal_mutable_destination();
  public:
  void unsafe_arena_set_allocated_destination(
      ::apollo::planning::DestinationConfig* destination);
  ::apollo::planning::DestinationConfig* unsafe_arena_release_destination();

  // .apollo.planning.KeepClearConfig keep_clear = 6;
  bool has_keep_clear() const;
  private:
  bool _internal_has_keep_clear() const;
  public:
  void clear_keep_clear();
  const ::apollo::planning::KeepClearConfig& keep_clear() const;
  ::apollo::planning::KeepClearConfig* release_keep_clear();
  ::apollo::planning::KeepClearConfig* mutable_keep_clear();
  void set_allocated_keep_clear(::apollo::planning::KeepClearConfig* keep_clear);
  private:
  const ::apollo::planning::KeepClearConfig& _internal_keep_clear() const;
  ::apollo::planning::KeepClearConfig* _internal_mutable_keep_clear();
  public:
  void unsafe_arena_set_allocated_keep_clear(
      ::apollo::planning::KeepClearConfig* keep_clear);
  ::apollo::planning::KeepClearConfig* unsafe_arena_release_keep_clear();

  // .apollo.planning.ReferenceLineEndConfig reference_line_end = 7;
  bool has_reference_line_end() const;
  private:
  bool _internal_has_reference_line_end() const;
  public:
  void clear_reference_line_end();
  const ::apollo::planning::ReferenceLineEndConfig& reference_line_end() const;
  ::apollo::planning::ReferenceLineEndConfig* release_reference_line_end();
  ::apollo::planning::ReferenceLineEndConfig* mutable_reference_line_end();
  void set_allocated_reference_line_end(::apollo::planning::ReferenceLineEndConfig* reference_line_end);
  private:
  const ::apollo::planning::ReferenceLineEndConfig& _internal_reference_line_end() const;
  ::apollo::planning::ReferenceLineEndConfig* _internal_mutable_reference_line_end();
  public:
  void unsafe_arena_set_allocated_reference_line_end(
      ::apollo::planning::ReferenceLineEndConfig* reference_line_end);
  ::apollo::planning::ReferenceLineEndConfig* unsafe_arena_release_reference_line_end();

  // .apollo.planning.ReroutingConfig rerouting = 8;
  bool has_rerouting() const;
  private:
  bool _internal_has_rerouting() const;
  public:
  void clear_rerouting();
  const ::apollo::planning::ReroutingConfig& rerouting() const;
  ::apollo::planning::ReroutingConfig* release_rerouting();
  ::apollo::planning::ReroutingConfig* mutable_rerouting();
  void set_allocated_rerouting(::apollo::planning::ReroutingConfig* rerouting);
  private:
  const ::apollo::planning::ReroutingConfig& _internal_rerouting() const;
  ::apollo::planning::ReroutingConfig* _internal_mutable_rerouting();
  public:
  void unsafe_arena_set_allocated_rerouting(
      ::apollo::planning::ReroutingConfig* rerouting);
  ::apollo::planning::ReroutingConfig* unsafe_arena_release_rerouting();

  // .apollo.planning.StopSignConfig stop_sign = 9;
  bool has_stop_sign() const;
  private:
  bool _internal_has_stop_sign() const;
  public:
  void clear_stop_sign();
  const ::apollo::planning::StopSignConfig& stop_sign() const;
  ::apollo::planning::StopSignConfig* release_stop_sign();
  ::apollo::planning::StopSignConfig* mutable_stop_sign();
  void set_allocated_stop_sign(::apollo::planning::StopSignConfig* stop_sign);
  private:
  const ::apollo::planning::StopSignConfig& _internal_stop_sign() const;
  ::apollo::planning::StopSignConfig* _internal_mutable_stop_sign();
  public:
  void unsafe_arena_set_allocated_stop_sign(
      ::apollo::planning::StopSignConfig* stop_sign);
  ::apollo::planning::StopSignConfig* unsafe_arena_release_stop_sign();

  // .apollo.planning.TrafficLightConfig traffic_light = 10;
  bool has_traffic_light() const;
  private:
  bool _internal_has_traffic_light() const;
  public:
  void clear_traffic_light();
  const ::apollo::planning::TrafficLightConfig& traffic_light() const;
  ::apollo::planning::TrafficLightConfig* release_traffic_light();
  ::apollo::planning::TrafficLightConfig* mutable_traffic_light();
  void set_allocated_traffic_light(::apollo::planning::TrafficLightConfig* traffic_light);
  private:
  const ::apollo::planning::TrafficLightConfig& _internal_traffic_light() const;
  ::apollo::planning::TrafficLightConfig* _internal_mutable_traffic_light();
  public:
  void unsafe_arena_set_allocated_traffic_light(
      ::apollo::planning::TrafficLightConfig* traffic_light);
  ::apollo::planning::TrafficLightConfig* unsafe_arena_release_traffic_light();

  // .apollo.planning.YieldSignConfig yield_sign = 11;
  bool has_yield_sign() const;
  private:
  bool _internal_has_yield_sign() const;
  public:
  void clear_yield_sign();
  const ::apollo::planning::YieldSignConfig& yield_sign() const;
  ::apollo::planning::YieldSignConfig* release_yield_sign();
  ::apollo::planning::YieldSignConfig* mutable_yield_sign();
  void set_allocated_yield_sign(::apollo::planning::YieldSignConfig* yield_sign);
  private:
  const ::apollo::planning::YieldSignConfig& _internal_yield_sign() const;
  ::apollo::planning::YieldSignConfig* _internal_mutable_yield_sign();
  public:
  void unsafe_arena_set_allocated_yield_sign(
      ::apollo::planning::YieldSignConfig* yield_sign);
  ::apollo::planning::YieldSignConfig* unsafe_arena_release_yield_sign();

  void clear_config();
  ConfigCase config_case() const;
  // @@protoc_insertion_point(class_scope:apollo.planning.TrafficRuleConfig)
 private:
  class _Internal;
  void set_has_backside_vehicle();
  void set_has_crosswalk();
  void set_has_destination();
  void set_has_keep_clear();
  void set_has_reference_line_end();
  void set_has_rerouting();
  void set_has_stop_sign();
  void set_has_traffic_light();
  void set_has_yield_sign();

  inline bool has_config() const;
  inline void clear_has_config();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool enabled_;
  int rule_id_;
  union ConfigUnion {
    ConfigUnion() {}
    ::apollo::planning::BacksideVehicleConfig* backside_vehicle_;
    ::apollo::planning::CrosswalkConfig* crosswalk_;
    ::apollo::planning::DestinationConfig* destination_;
    ::apollo::planning::KeepClearConfig* keep_clear_;
    ::apollo::planning::ReferenceLineEndConfig* reference_line_end_;
    ::apollo::planning::ReroutingConfig* rerouting_;
    ::apollo::planning::StopSignConfig* stop_sign_;
    ::apollo::planning::TrafficLightConfig* traffic_light_;
    ::apollo::planning::YieldSignConfig* yield_sign_;
  } config_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// -------------------------------------------------------------------

class TrafficRuleConfigs PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.planning.TrafficRuleConfigs) */ {
 public:
  inline TrafficRuleConfigs() : TrafficRuleConfigs(nullptr) {}
  virtual ~TrafficRuleConfigs();

  TrafficRuleConfigs(const TrafficRuleConfigs& from);
  TrafficRuleConfigs(TrafficRuleConfigs&& from) noexcept
    : TrafficRuleConfigs() {
    *this = ::std::move(from);
  }

  inline TrafficRuleConfigs& operator=(const TrafficRuleConfigs& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficRuleConfigs& operator=(TrafficRuleConfigs&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TrafficRuleConfigs& default_instance();

  static inline const TrafficRuleConfigs* internal_default_instance() {
    return reinterpret_cast<const TrafficRuleConfigs*>(
               &_TrafficRuleConfigs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TrafficRuleConfigs& a, TrafficRuleConfigs& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficRuleConfigs* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficRuleConfigs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TrafficRuleConfigs* New() const final {
    return CreateMaybeMessage<TrafficRuleConfigs>(nullptr);
  }

  TrafficRuleConfigs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TrafficRuleConfigs>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TrafficRuleConfigs& from);
  void MergeFrom(const TrafficRuleConfigs& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficRuleConfigs* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.planning.TrafficRuleConfigs";
  }
  protected:
  explicit TrafficRuleConfigs(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto);
    return ::descriptor_table_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
  };
  // repeated .apollo.planning.TrafficRuleConfig config = 1;
  int config_size() const;
  private:
  int _internal_config_size() const;
  public:
  void clear_config();
  ::apollo::planning::TrafficRuleConfig* mutable_config(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TrafficRuleConfig >*
      mutable_config();
  private:
  const ::apollo::planning::TrafficRuleConfig& _internal_config(int index) const;
  ::apollo::planning::TrafficRuleConfig* _internal_add_config();
  public:
  const ::apollo::planning::TrafficRuleConfig& config(int index) const;
  ::apollo::planning::TrafficRuleConfig* add_config();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TrafficRuleConfig >&
      config() const;

  // @@protoc_insertion_point(class_scope:apollo.planning.TrafficRuleConfigs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TrafficRuleConfig > config_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BacksideVehicleConfig

// optional double backside_lane_width = 1 [default = 4];
inline bool BacksideVehicleConfig::_internal_has_backside_lane_width() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BacksideVehicleConfig::has_backside_lane_width() const {
  return _internal_has_backside_lane_width();
}
inline void BacksideVehicleConfig::clear_backside_lane_width() {
  backside_lane_width_ = 4;
  _has_bits_[0] &= ~0x00000001u;
}
inline double BacksideVehicleConfig::_internal_backside_lane_width() const {
  return backside_lane_width_;
}
inline double BacksideVehicleConfig::backside_lane_width() const {
  // @@protoc_insertion_point(field_get:apollo.planning.BacksideVehicleConfig.backside_lane_width)
  return _internal_backside_lane_width();
}
inline void BacksideVehicleConfig::_internal_set_backside_lane_width(double value) {
  _has_bits_[0] |= 0x00000001u;
  backside_lane_width_ = value;
}
inline void BacksideVehicleConfig::set_backside_lane_width(double value) {
  _internal_set_backside_lane_width(value);
  // @@protoc_insertion_point(field_set:apollo.planning.BacksideVehicleConfig.backside_lane_width)
}

// -------------------------------------------------------------------

// CrosswalkConfig

// optional double stop_distance = 1 [default = 1];
inline bool CrosswalkConfig::_internal_has_stop_distance() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CrosswalkConfig::has_stop_distance() const {
  return _internal_has_stop_distance();
}
inline void CrosswalkConfig::clear_stop_distance() {
  stop_distance_ = 1;
  _has_bits_[0] &= ~0x00000001u;
}
inline double CrosswalkConfig::_internal_stop_distance() const {
  return stop_distance_;
}
inline double CrosswalkConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkConfig.stop_distance)
  return _internal_stop_distance();
}
inline void CrosswalkConfig::_internal_set_stop_distance(double value) {
  _has_bits_[0] |= 0x00000001u;
  stop_distance_ = value;
}
inline void CrosswalkConfig::set_stop_distance(double value) {
  _internal_set_stop_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkConfig.stop_distance)
}

// optional double max_stop_deceleration = 2 [default = 4];
inline bool CrosswalkConfig::_internal_has_max_stop_deceleration() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CrosswalkConfig::has_max_stop_deceleration() const {
  return _internal_has_max_stop_deceleration();
}
inline void CrosswalkConfig::clear_max_stop_deceleration() {
  max_stop_deceleration_ = 4;
  _has_bits_[0] &= ~0x00000002u;
}
inline double CrosswalkConfig::_internal_max_stop_deceleration() const {
  return max_stop_deceleration_;
}
inline double CrosswalkConfig::max_stop_deceleration() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkConfig.max_stop_deceleration)
  return _internal_max_stop_deceleration();
}
inline void CrosswalkConfig::_internal_set_max_stop_deceleration(double value) {
  _has_bits_[0] |= 0x00000002u;
  max_stop_deceleration_ = value;
}
inline void CrosswalkConfig::set_max_stop_deceleration(double value) {
  _internal_set_max_stop_deceleration(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkConfig.max_stop_deceleration)
}

// optional double min_pass_s_distance = 3 [default = 1];
inline bool CrosswalkConfig::_internal_has_min_pass_s_distance() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CrosswalkConfig::has_min_pass_s_distance() const {
  return _internal_has_min_pass_s_distance();
}
inline void CrosswalkConfig::clear_min_pass_s_distance() {
  min_pass_s_distance_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline double CrosswalkConfig::_internal_min_pass_s_distance() const {
  return min_pass_s_distance_;
}
inline double CrosswalkConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkConfig.min_pass_s_distance)
  return _internal_min_pass_s_distance();
}
inline void CrosswalkConfig::_internal_set_min_pass_s_distance(double value) {
  _has_bits_[0] |= 0x00000004u;
  min_pass_s_distance_ = value;
}
inline void CrosswalkConfig::set_min_pass_s_distance(double value) {
  _internal_set_min_pass_s_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkConfig.min_pass_s_distance)
}

// optional double max_valid_stop_distance = 4 [default = 3];
inline bool CrosswalkConfig::_internal_has_max_valid_stop_distance() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CrosswalkConfig::has_max_valid_stop_distance() const {
  return _internal_has_max_valid_stop_distance();
}
inline void CrosswalkConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 3;
  _has_bits_[0] &= ~0x00000008u;
}
inline double CrosswalkConfig::_internal_max_valid_stop_distance() const {
  return max_valid_stop_distance_;
}
inline double CrosswalkConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkConfig.max_valid_stop_distance)
  return _internal_max_valid_stop_distance();
}
inline void CrosswalkConfig::_internal_set_max_valid_stop_distance(double value) {
  _has_bits_[0] |= 0x00000008u;
  max_valid_stop_distance_ = value;
}
inline void CrosswalkConfig::set_max_valid_stop_distance(double value) {
  _internal_set_max_valid_stop_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkConfig.max_valid_stop_distance)
}

// optional double expand_s_distance = 5 [default = 2];
inline bool CrosswalkConfig::_internal_has_expand_s_distance() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CrosswalkConfig::has_expand_s_distance() const {
  return _internal_has_expand_s_distance();
}
inline void CrosswalkConfig::clear_expand_s_distance() {
  expand_s_distance_ = 2;
  _has_bits_[0] &= ~0x00000010u;
}
inline double CrosswalkConfig::_internal_expand_s_distance() const {
  return expand_s_distance_;
}
inline double CrosswalkConfig::expand_s_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkConfig.expand_s_distance)
  return _internal_expand_s_distance();
}
inline void CrosswalkConfig::_internal_set_expand_s_distance(double value) {
  _has_bits_[0] |= 0x00000010u;
  expand_s_distance_ = value;
}
inline void CrosswalkConfig::set_expand_s_distance(double value) {
  _internal_set_expand_s_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkConfig.expand_s_distance)
}

// optional double stop_strict_l_distance = 6 [default = 4];
inline bool CrosswalkConfig::_internal_has_stop_strict_l_distance() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CrosswalkConfig::has_stop_strict_l_distance() const {
  return _internal_has_stop_strict_l_distance();
}
inline void CrosswalkConfig::clear_stop_strict_l_distance() {
  stop_strict_l_distance_ = 4;
  _has_bits_[0] &= ~0x00000020u;
}
inline double CrosswalkConfig::_internal_stop_strict_l_distance() const {
  return stop_strict_l_distance_;
}
inline double CrosswalkConfig::stop_strict_l_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkConfig.stop_strict_l_distance)
  return _internal_stop_strict_l_distance();
}
inline void CrosswalkConfig::_internal_set_stop_strict_l_distance(double value) {
  _has_bits_[0] |= 0x00000020u;
  stop_strict_l_distance_ = value;
}
inline void CrosswalkConfig::set_stop_strict_l_distance(double value) {
  _internal_set_stop_strict_l_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkConfig.stop_strict_l_distance)
}

// optional double stop_loose_l_distance = 7 [default = 5];
inline bool CrosswalkConfig::_internal_has_stop_loose_l_distance() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CrosswalkConfig::has_stop_loose_l_distance() const {
  return _internal_has_stop_loose_l_distance();
}
inline void CrosswalkConfig::clear_stop_loose_l_distance() {
  stop_loose_l_distance_ = 5;
  _has_bits_[0] &= ~0x00000040u;
}
inline double CrosswalkConfig::_internal_stop_loose_l_distance() const {
  return stop_loose_l_distance_;
}
inline double CrosswalkConfig::stop_loose_l_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkConfig.stop_loose_l_distance)
  return _internal_stop_loose_l_distance();
}
inline void CrosswalkConfig::_internal_set_stop_loose_l_distance(double value) {
  _has_bits_[0] |= 0x00000040u;
  stop_loose_l_distance_ = value;
}
inline void CrosswalkConfig::set_stop_loose_l_distance(double value) {
  _internal_set_stop_loose_l_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkConfig.stop_loose_l_distance)
}

// optional double stop_timeout = 8 [default = 10];
inline bool CrosswalkConfig::_internal_has_stop_timeout() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CrosswalkConfig::has_stop_timeout() const {
  return _internal_has_stop_timeout();
}
inline void CrosswalkConfig::clear_stop_timeout() {
  stop_timeout_ = 10;
  _has_bits_[0] &= ~0x00000080u;
}
inline double CrosswalkConfig::_internal_stop_timeout() const {
  return stop_timeout_;
}
inline double CrosswalkConfig::stop_timeout() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkConfig.stop_timeout)
  return _internal_stop_timeout();
}
inline void CrosswalkConfig::_internal_set_stop_timeout(double value) {
  _has_bits_[0] |= 0x00000080u;
  stop_timeout_ = value;
}
inline void CrosswalkConfig::set_stop_timeout(double value) {
  _internal_set_stop_timeout(value);
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkConfig.stop_timeout)
}

// -------------------------------------------------------------------

// DestinationConfig

// optional double stop_distance = 1 [default = 0.5];
inline bool DestinationConfig::_internal_has_stop_distance() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DestinationConfig::has_stop_distance() const {
  return _internal_has_stop_distance();
}
inline void DestinationConfig::clear_stop_distance() {
  stop_distance_ = 0.5;
  _has_bits_[0] &= ~0x00000001u;
}
inline double DestinationConfig::_internal_stop_distance() const {
  return stop_distance_;
}
inline double DestinationConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.DestinationConfig.stop_distance)
  return _internal_stop_distance();
}
inline void DestinationConfig::_internal_set_stop_distance(double value) {
  _has_bits_[0] |= 0x00000001u;
  stop_distance_ = value;
}
inline void DestinationConfig::set_stop_distance(double value) {
  _internal_set_stop_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.DestinationConfig.stop_distance)
}

// -------------------------------------------------------------------

// KeepClearConfig

// optional bool enable_keep_clear_zone = 1 [default = true];
inline bool KeepClearConfig::_internal_has_enable_keep_clear_zone() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KeepClearConfig::has_enable_keep_clear_zone() const {
  return _internal_has_enable_keep_clear_zone();
}
inline void KeepClearConfig::clear_enable_keep_clear_zone() {
  enable_keep_clear_zone_ = true;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool KeepClearConfig::_internal_enable_keep_clear_zone() const {
  return enable_keep_clear_zone_;
}
inline bool KeepClearConfig::enable_keep_clear_zone() const {
  // @@protoc_insertion_point(field_get:apollo.planning.KeepClearConfig.enable_keep_clear_zone)
  return _internal_enable_keep_clear_zone();
}
inline void KeepClearConfig::_internal_set_enable_keep_clear_zone(bool value) {
  _has_bits_[0] |= 0x00000001u;
  enable_keep_clear_zone_ = value;
}
inline void KeepClearConfig::set_enable_keep_clear_zone(bool value) {
  _internal_set_enable_keep_clear_zone(value);
  // @@protoc_insertion_point(field_set:apollo.planning.KeepClearConfig.enable_keep_clear_zone)
}

// optional bool enable_junction = 2 [default = true];
inline bool KeepClearConfig::_internal_has_enable_junction() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KeepClearConfig::has_enable_junction() const {
  return _internal_has_enable_junction();
}
inline void KeepClearConfig::clear_enable_junction() {
  enable_junction_ = true;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool KeepClearConfig::_internal_enable_junction() const {
  return enable_junction_;
}
inline bool KeepClearConfig::enable_junction() const {
  // @@protoc_insertion_point(field_get:apollo.planning.KeepClearConfig.enable_junction)
  return _internal_enable_junction();
}
inline void KeepClearConfig::_internal_set_enable_junction(bool value) {
  _has_bits_[0] |= 0x00000002u;
  enable_junction_ = value;
}
inline void KeepClearConfig::set_enable_junction(bool value) {
  _internal_set_enable_junction(value);
  // @@protoc_insertion_point(field_set:apollo.planning.KeepClearConfig.enable_junction)
}

// optional double min_pass_s_distance = 3 [default = 2];
inline bool KeepClearConfig::_internal_has_min_pass_s_distance() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool KeepClearConfig::has_min_pass_s_distance() const {
  return _internal_has_min_pass_s_distance();
}
inline void KeepClearConfig::clear_min_pass_s_distance() {
  min_pass_s_distance_ = 2;
  _has_bits_[0] &= ~0x00000004u;
}
inline double KeepClearConfig::_internal_min_pass_s_distance() const {
  return min_pass_s_distance_;
}
inline double KeepClearConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.KeepClearConfig.min_pass_s_distance)
  return _internal_min_pass_s_distance();
}
inline void KeepClearConfig::_internal_set_min_pass_s_distance(double value) {
  _has_bits_[0] |= 0x00000004u;
  min_pass_s_distance_ = value;
}
inline void KeepClearConfig::set_min_pass_s_distance(double value) {
  _internal_set_min_pass_s_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.KeepClearConfig.min_pass_s_distance)
}

// optional double align_with_traffic_sign_tolerance = 4 [default = 4.5];
inline bool KeepClearConfig::_internal_has_align_with_traffic_sign_tolerance() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool KeepClearConfig::has_align_with_traffic_sign_tolerance() const {
  return _internal_has_align_with_traffic_sign_tolerance();
}
inline void KeepClearConfig::clear_align_with_traffic_sign_tolerance() {
  align_with_traffic_sign_tolerance_ = 4.5;
  _has_bits_[0] &= ~0x00000008u;
}
inline double KeepClearConfig::_internal_align_with_traffic_sign_tolerance() const {
  return align_with_traffic_sign_tolerance_;
}
inline double KeepClearConfig::align_with_traffic_sign_tolerance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.KeepClearConfig.align_with_traffic_sign_tolerance)
  return _internal_align_with_traffic_sign_tolerance();
}
inline void KeepClearConfig::_internal_set_align_with_traffic_sign_tolerance(double value) {
  _has_bits_[0] |= 0x00000008u;
  align_with_traffic_sign_tolerance_ = value;
}
inline void KeepClearConfig::set_align_with_traffic_sign_tolerance(double value) {
  _internal_set_align_with_traffic_sign_tolerance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.KeepClearConfig.align_with_traffic_sign_tolerance)
}

// -------------------------------------------------------------------

// ReferenceLineEndConfig

// optional double stop_distance = 1 [default = 0.5];
inline bool ReferenceLineEndConfig::_internal_has_stop_distance() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReferenceLineEndConfig::has_stop_distance() const {
  return _internal_has_stop_distance();
}
inline void ReferenceLineEndConfig::clear_stop_distance() {
  stop_distance_ = 0.5;
  _has_bits_[0] &= ~0x00000001u;
}
inline double ReferenceLineEndConfig::_internal_stop_distance() const {
  return stop_distance_;
}
inline double ReferenceLineEndConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ReferenceLineEndConfig.stop_distance)
  return _internal_stop_distance();
}
inline void ReferenceLineEndConfig::_internal_set_stop_distance(double value) {
  _has_bits_[0] |= 0x00000001u;
  stop_distance_ = value;
}
inline void ReferenceLineEndConfig::set_stop_distance(double value) {
  _internal_set_stop_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ReferenceLineEndConfig.stop_distance)
}

// optional double min_reference_line_remain_length = 2 [default = 50];
inline bool ReferenceLineEndConfig::_internal_has_min_reference_line_remain_length() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ReferenceLineEndConfig::has_min_reference_line_remain_length() const {
  return _internal_has_min_reference_line_remain_length();
}
inline void ReferenceLineEndConfig::clear_min_reference_line_remain_length() {
  min_reference_line_remain_length_ = 50;
  _has_bits_[0] &= ~0x00000002u;
}
inline double ReferenceLineEndConfig::_internal_min_reference_line_remain_length() const {
  return min_reference_line_remain_length_;
}
inline double ReferenceLineEndConfig::min_reference_line_remain_length() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ReferenceLineEndConfig.min_reference_line_remain_length)
  return _internal_min_reference_line_remain_length();
}
inline void ReferenceLineEndConfig::_internal_set_min_reference_line_remain_length(double value) {
  _has_bits_[0] |= 0x00000002u;
  min_reference_line_remain_length_ = value;
}
inline void ReferenceLineEndConfig::set_min_reference_line_remain_length(double value) {
  _internal_set_min_reference_line_remain_length(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ReferenceLineEndConfig.min_reference_line_remain_length)
}

// -------------------------------------------------------------------

// ReroutingConfig

// optional double cooldown_time = 1 [default = 3];
inline bool ReroutingConfig::_internal_has_cooldown_time() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReroutingConfig::has_cooldown_time() const {
  return _internal_has_cooldown_time();
}
inline void ReroutingConfig::clear_cooldown_time() {
  cooldown_time_ = 3;
  _has_bits_[0] &= ~0x00000001u;
}
inline double ReroutingConfig::_internal_cooldown_time() const {
  return cooldown_time_;
}
inline double ReroutingConfig::cooldown_time() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ReroutingConfig.cooldown_time)
  return _internal_cooldown_time();
}
inline void ReroutingConfig::_internal_set_cooldown_time(double value) {
  _has_bits_[0] |= 0x00000001u;
  cooldown_time_ = value;
}
inline void ReroutingConfig::set_cooldown_time(double value) {
  _internal_set_cooldown_time(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ReroutingConfig.cooldown_time)
}

// optional double prepare_rerouting_time = 2 [default = 2];
inline bool ReroutingConfig::_internal_has_prepare_rerouting_time() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ReroutingConfig::has_prepare_rerouting_time() const {
  return _internal_has_prepare_rerouting_time();
}
inline void ReroutingConfig::clear_prepare_rerouting_time() {
  prepare_rerouting_time_ = 2;
  _has_bits_[0] &= ~0x00000002u;
}
inline double ReroutingConfig::_internal_prepare_rerouting_time() const {
  return prepare_rerouting_time_;
}
inline double ReroutingConfig::prepare_rerouting_time() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ReroutingConfig.prepare_rerouting_time)
  return _internal_prepare_rerouting_time();
}
inline void ReroutingConfig::_internal_set_prepare_rerouting_time(double value) {
  _has_bits_[0] |= 0x00000002u;
  prepare_rerouting_time_ = value;
}
inline void ReroutingConfig::set_prepare_rerouting_time(double value) {
  _internal_set_prepare_rerouting_time(value);
  // @@protoc_insertion_point(field_set:apollo.planning.ReroutingConfig.prepare_rerouting_time)
}

// -------------------------------------------------------------------

// StopSignConfig

// optional bool enabled = 1 [default = true];
inline bool StopSignConfig::_internal_has_enabled() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StopSignConfig::has_enabled() const {
  return _internal_has_enabled();
}
inline void StopSignConfig::clear_enabled() {
  enabled_ = true;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool StopSignConfig::_internal_enabled() const {
  return enabled_;
}
inline bool StopSignConfig::enabled() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignConfig.enabled)
  return _internal_enabled();
}
inline void StopSignConfig::_internal_set_enabled(bool value) {
  _has_bits_[0] |= 0x00000001u;
  enabled_ = value;
}
inline void StopSignConfig::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignConfig.enabled)
}

// optional double stop_distance = 2 [default = 1];
inline bool StopSignConfig::_internal_has_stop_distance() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StopSignConfig::has_stop_distance() const {
  return _internal_has_stop_distance();
}
inline void StopSignConfig::clear_stop_distance() {
  stop_distance_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline double StopSignConfig::_internal_stop_distance() const {
  return stop_distance_;
}
inline double StopSignConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignConfig.stop_distance)
  return _internal_stop_distance();
}
inline void StopSignConfig::_internal_set_stop_distance(double value) {
  _has_bits_[0] |= 0x00000002u;
  stop_distance_ = value;
}
inline void StopSignConfig::set_stop_distance(double value) {
  _internal_set_stop_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignConfig.stop_distance)
}

// -------------------------------------------------------------------

// TrafficLightConfig

// optional bool enabled = 1 [default = true];
inline bool TrafficLightConfig::_internal_has_enabled() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TrafficLightConfig::has_enabled() const {
  return _internal_has_enabled();
}
inline void TrafficLightConfig::clear_enabled() {
  enabled_ = true;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool TrafficLightConfig::_internal_enabled() const {
  return enabled_;
}
inline bool TrafficLightConfig::enabled() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficLightConfig.enabled)
  return _internal_enabled();
}
inline void TrafficLightConfig::_internal_set_enabled(bool value) {
  _has_bits_[0] |= 0x00000001u;
  enabled_ = value;
}
inline void TrafficLightConfig::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficLightConfig.enabled)
}

// optional double stop_distance = 2 [default = 1];
inline bool TrafficLightConfig::_internal_has_stop_distance() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TrafficLightConfig::has_stop_distance() const {
  return _internal_has_stop_distance();
}
inline void TrafficLightConfig::clear_stop_distance() {
  stop_distance_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline double TrafficLightConfig::_internal_stop_distance() const {
  return stop_distance_;
}
inline double TrafficLightConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficLightConfig.stop_distance)
  return _internal_stop_distance();
}
inline void TrafficLightConfig::_internal_set_stop_distance(double value) {
  _has_bits_[0] |= 0x00000002u;
  stop_distance_ = value;
}
inline void TrafficLightConfig::set_stop_distance(double value) {
  _internal_set_stop_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficLightConfig.stop_distance)
}

// optional double max_stop_deceleration = 3 [default = 4];
inline bool TrafficLightConfig::_internal_has_max_stop_deceleration() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TrafficLightConfig::has_max_stop_deceleration() const {
  return _internal_has_max_stop_deceleration();
}
inline void TrafficLightConfig::clear_max_stop_deceleration() {
  max_stop_deceleration_ = 4;
  _has_bits_[0] &= ~0x00000004u;
}
inline double TrafficLightConfig::_internal_max_stop_deceleration() const {
  return max_stop_deceleration_;
}
inline double TrafficLightConfig::max_stop_deceleration() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficLightConfig.max_stop_deceleration)
  return _internal_max_stop_deceleration();
}
inline void TrafficLightConfig::_internal_set_max_stop_deceleration(double value) {
  _has_bits_[0] |= 0x00000004u;
  max_stop_deceleration_ = value;
}
inline void TrafficLightConfig::set_max_stop_deceleration(double value) {
  _internal_set_max_stop_deceleration(value);
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficLightConfig.max_stop_deceleration)
}

// -------------------------------------------------------------------

// YieldSignConfig

// optional bool enabled = 1 [default = true];
inline bool YieldSignConfig::_internal_has_enabled() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool YieldSignConfig::has_enabled() const {
  return _internal_has_enabled();
}
inline void YieldSignConfig::clear_enabled() {
  enabled_ = true;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool YieldSignConfig::_internal_enabled() const {
  return enabled_;
}
inline bool YieldSignConfig::enabled() const {
  // @@protoc_insertion_point(field_get:apollo.planning.YieldSignConfig.enabled)
  return _internal_enabled();
}
inline void YieldSignConfig::_internal_set_enabled(bool value) {
  _has_bits_[0] |= 0x00000001u;
  enabled_ = value;
}
inline void YieldSignConfig::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:apollo.planning.YieldSignConfig.enabled)
}

// optional double stop_distance = 2 [default = 1];
inline bool YieldSignConfig::_internal_has_stop_distance() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool YieldSignConfig::has_stop_distance() const {
  return _internal_has_stop_distance();
}
inline void YieldSignConfig::clear_stop_distance() {
  stop_distance_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline double YieldSignConfig::_internal_stop_distance() const {
  return stop_distance_;
}
inline double YieldSignConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.YieldSignConfig.stop_distance)
  return _internal_stop_distance();
}
inline void YieldSignConfig::_internal_set_stop_distance(double value) {
  _has_bits_[0] |= 0x00000002u;
  stop_distance_ = value;
}
inline void YieldSignConfig::set_stop_distance(double value) {
  _internal_set_stop_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.YieldSignConfig.stop_distance)
}

// optional double start_watch_distance = 3 [default = 2];
inline bool YieldSignConfig::_internal_has_start_watch_distance() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool YieldSignConfig::has_start_watch_distance() const {
  return _internal_has_start_watch_distance();
}
inline void YieldSignConfig::clear_start_watch_distance() {
  start_watch_distance_ = 2;
  _has_bits_[0] &= ~0x00000004u;
}
inline double YieldSignConfig::_internal_start_watch_distance() const {
  return start_watch_distance_;
}
inline double YieldSignConfig::start_watch_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.YieldSignConfig.start_watch_distance)
  return _internal_start_watch_distance();
}
inline void YieldSignConfig::_internal_set_start_watch_distance(double value) {
  _has_bits_[0] |= 0x00000004u;
  start_watch_distance_ = value;
}
inline void YieldSignConfig::set_start_watch_distance(double value) {
  _internal_set_start_watch_distance(value);
  // @@protoc_insertion_point(field_set:apollo.planning.YieldSignConfig.start_watch_distance)
}

// -------------------------------------------------------------------

// TrafficRuleConfig

// optional .apollo.planning.TrafficRuleConfig.RuleId rule_id = 1;
inline bool TrafficRuleConfig::_internal_has_rule_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TrafficRuleConfig::has_rule_id() const {
  return _internal_has_rule_id();
}
inline void TrafficRuleConfig::clear_rule_id() {
  rule_id_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::apollo::planning::TrafficRuleConfig_RuleId TrafficRuleConfig::_internal_rule_id() const {
  return static_cast< ::apollo::planning::TrafficRuleConfig_RuleId >(rule_id_);
}
inline ::apollo::planning::TrafficRuleConfig_RuleId TrafficRuleConfig::rule_id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.rule_id)
  return _internal_rule_id();
}
inline void TrafficRuleConfig::_internal_set_rule_id(::apollo::planning::TrafficRuleConfig_RuleId value) {
  assert(::apollo::planning::TrafficRuleConfig_RuleId_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  rule_id_ = value;
}
inline void TrafficRuleConfig::set_rule_id(::apollo::planning::TrafficRuleConfig_RuleId value) {
  _internal_set_rule_id(value);
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficRuleConfig.rule_id)
}

// optional bool enabled = 2;
inline bool TrafficRuleConfig::_internal_has_enabled() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TrafficRuleConfig::has_enabled() const {
  return _internal_has_enabled();
}
inline void TrafficRuleConfig::clear_enabled() {
  enabled_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool TrafficRuleConfig::_internal_enabled() const {
  return enabled_;
}
inline bool TrafficRuleConfig::enabled() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.enabled)
  return _internal_enabled();
}
inline void TrafficRuleConfig::_internal_set_enabled(bool value) {
  _has_bits_[0] |= 0x00000001u;
  enabled_ = value;
}
inline void TrafficRuleConfig::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficRuleConfig.enabled)
}

// .apollo.planning.BacksideVehicleConfig backside_vehicle = 3;
inline bool TrafficRuleConfig::_internal_has_backside_vehicle() const {
  return config_case() == kBacksideVehicle;
}
inline bool TrafficRuleConfig::has_backside_vehicle() const {
  return _internal_has_backside_vehicle();
}
inline void TrafficRuleConfig::set_has_backside_vehicle() {
  _oneof_case_[0] = kBacksideVehicle;
}
inline void TrafficRuleConfig::clear_backside_vehicle() {
  if (_internal_has_backside_vehicle()) {
    if (GetArena() == nullptr) {
      delete config_.backside_vehicle_;
    }
    clear_has_config();
  }
}
inline ::apollo::planning::BacksideVehicleConfig* TrafficRuleConfig::release_backside_vehicle() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.backside_vehicle)
  if (_internal_has_backside_vehicle()) {
    clear_has_config();
      ::apollo::planning::BacksideVehicleConfig* temp = config_.backside_vehicle_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    config_.backside_vehicle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::BacksideVehicleConfig& TrafficRuleConfig::_internal_backside_vehicle() const {
  return _internal_has_backside_vehicle()
      ? *config_.backside_vehicle_
      : reinterpret_cast< ::apollo::planning::BacksideVehicleConfig&>(::apollo::planning::_BacksideVehicleConfig_default_instance_);
}
inline const ::apollo::planning::BacksideVehicleConfig& TrafficRuleConfig::backside_vehicle() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.backside_vehicle)
  return _internal_backside_vehicle();
}
inline ::apollo::planning::BacksideVehicleConfig* TrafficRuleConfig::unsafe_arena_release_backside_vehicle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.planning.TrafficRuleConfig.backside_vehicle)
  if (_internal_has_backside_vehicle()) {
    clear_has_config();
    ::apollo::planning::BacksideVehicleConfig* temp = config_.backside_vehicle_;
    config_.backside_vehicle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrafficRuleConfig::unsafe_arena_set_allocated_backside_vehicle(::apollo::planning::BacksideVehicleConfig* backside_vehicle) {
  clear_config();
  if (backside_vehicle) {
    set_has_backside_vehicle();
    config_.backside_vehicle_ = backside_vehicle;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.TrafficRuleConfig.backside_vehicle)
}
inline ::apollo::planning::BacksideVehicleConfig* TrafficRuleConfig::_internal_mutable_backside_vehicle() {
  if (!_internal_has_backside_vehicle()) {
    clear_config();
    set_has_backside_vehicle();
    config_.backside_vehicle_ = CreateMaybeMessage< ::apollo::planning::BacksideVehicleConfig >(GetArena());
  }
  return config_.backside_vehicle_;
}
inline ::apollo::planning::BacksideVehicleConfig* TrafficRuleConfig::mutable_backside_vehicle() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.backside_vehicle)
  return _internal_mutable_backside_vehicle();
}

// .apollo.planning.CrosswalkConfig crosswalk = 4;
inline bool TrafficRuleConfig::_internal_has_crosswalk() const {
  return config_case() == kCrosswalk;
}
inline bool TrafficRuleConfig::has_crosswalk() const {
  return _internal_has_crosswalk();
}
inline void TrafficRuleConfig::set_has_crosswalk() {
  _oneof_case_[0] = kCrosswalk;
}
inline void TrafficRuleConfig::clear_crosswalk() {
  if (_internal_has_crosswalk()) {
    if (GetArena() == nullptr) {
      delete config_.crosswalk_;
    }
    clear_has_config();
  }
}
inline ::apollo::planning::CrosswalkConfig* TrafficRuleConfig::release_crosswalk() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.crosswalk)
  if (_internal_has_crosswalk()) {
    clear_has_config();
      ::apollo::planning::CrosswalkConfig* temp = config_.crosswalk_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    config_.crosswalk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::CrosswalkConfig& TrafficRuleConfig::_internal_crosswalk() const {
  return _internal_has_crosswalk()
      ? *config_.crosswalk_
      : reinterpret_cast< ::apollo::planning::CrosswalkConfig&>(::apollo::planning::_CrosswalkConfig_default_instance_);
}
inline const ::apollo::planning::CrosswalkConfig& TrafficRuleConfig::crosswalk() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.crosswalk)
  return _internal_crosswalk();
}
inline ::apollo::planning::CrosswalkConfig* TrafficRuleConfig::unsafe_arena_release_crosswalk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.planning.TrafficRuleConfig.crosswalk)
  if (_internal_has_crosswalk()) {
    clear_has_config();
    ::apollo::planning::CrosswalkConfig* temp = config_.crosswalk_;
    config_.crosswalk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrafficRuleConfig::unsafe_arena_set_allocated_crosswalk(::apollo::planning::CrosswalkConfig* crosswalk) {
  clear_config();
  if (crosswalk) {
    set_has_crosswalk();
    config_.crosswalk_ = crosswalk;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.TrafficRuleConfig.crosswalk)
}
inline ::apollo::planning::CrosswalkConfig* TrafficRuleConfig::_internal_mutable_crosswalk() {
  if (!_internal_has_crosswalk()) {
    clear_config();
    set_has_crosswalk();
    config_.crosswalk_ = CreateMaybeMessage< ::apollo::planning::CrosswalkConfig >(GetArena());
  }
  return config_.crosswalk_;
}
inline ::apollo::planning::CrosswalkConfig* TrafficRuleConfig::mutable_crosswalk() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.crosswalk)
  return _internal_mutable_crosswalk();
}

// .apollo.planning.DestinationConfig destination = 5;
inline bool TrafficRuleConfig::_internal_has_destination() const {
  return config_case() == kDestination;
}
inline bool TrafficRuleConfig::has_destination() const {
  return _internal_has_destination();
}
inline void TrafficRuleConfig::set_has_destination() {
  _oneof_case_[0] = kDestination;
}
inline void TrafficRuleConfig::clear_destination() {
  if (_internal_has_destination()) {
    if (GetArena() == nullptr) {
      delete config_.destination_;
    }
    clear_has_config();
  }
}
inline ::apollo::planning::DestinationConfig* TrafficRuleConfig::release_destination() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.destination)
  if (_internal_has_destination()) {
    clear_has_config();
      ::apollo::planning::DestinationConfig* temp = config_.destination_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    config_.destination_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::DestinationConfig& TrafficRuleConfig::_internal_destination() const {
  return _internal_has_destination()
      ? *config_.destination_
      : reinterpret_cast< ::apollo::planning::DestinationConfig&>(::apollo::planning::_DestinationConfig_default_instance_);
}
inline const ::apollo::planning::DestinationConfig& TrafficRuleConfig::destination() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.destination)
  return _internal_destination();
}
inline ::apollo::planning::DestinationConfig* TrafficRuleConfig::unsafe_arena_release_destination() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.planning.TrafficRuleConfig.destination)
  if (_internal_has_destination()) {
    clear_has_config();
    ::apollo::planning::DestinationConfig* temp = config_.destination_;
    config_.destination_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrafficRuleConfig::unsafe_arena_set_allocated_destination(::apollo::planning::DestinationConfig* destination) {
  clear_config();
  if (destination) {
    set_has_destination();
    config_.destination_ = destination;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.TrafficRuleConfig.destination)
}
inline ::apollo::planning::DestinationConfig* TrafficRuleConfig::_internal_mutable_destination() {
  if (!_internal_has_destination()) {
    clear_config();
    set_has_destination();
    config_.destination_ = CreateMaybeMessage< ::apollo::planning::DestinationConfig >(GetArena());
  }
  return config_.destination_;
}
inline ::apollo::planning::DestinationConfig* TrafficRuleConfig::mutable_destination() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.destination)
  return _internal_mutable_destination();
}

// .apollo.planning.KeepClearConfig keep_clear = 6;
inline bool TrafficRuleConfig::_internal_has_keep_clear() const {
  return config_case() == kKeepClear;
}
inline bool TrafficRuleConfig::has_keep_clear() const {
  return _internal_has_keep_clear();
}
inline void TrafficRuleConfig::set_has_keep_clear() {
  _oneof_case_[0] = kKeepClear;
}
inline void TrafficRuleConfig::clear_keep_clear() {
  if (_internal_has_keep_clear()) {
    if (GetArena() == nullptr) {
      delete config_.keep_clear_;
    }
    clear_has_config();
  }
}
inline ::apollo::planning::KeepClearConfig* TrafficRuleConfig::release_keep_clear() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.keep_clear)
  if (_internal_has_keep_clear()) {
    clear_has_config();
      ::apollo::planning::KeepClearConfig* temp = config_.keep_clear_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    config_.keep_clear_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::KeepClearConfig& TrafficRuleConfig::_internal_keep_clear() const {
  return _internal_has_keep_clear()
      ? *config_.keep_clear_
      : reinterpret_cast< ::apollo::planning::KeepClearConfig&>(::apollo::planning::_KeepClearConfig_default_instance_);
}
inline const ::apollo::planning::KeepClearConfig& TrafficRuleConfig::keep_clear() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.keep_clear)
  return _internal_keep_clear();
}
inline ::apollo::planning::KeepClearConfig* TrafficRuleConfig::unsafe_arena_release_keep_clear() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.planning.TrafficRuleConfig.keep_clear)
  if (_internal_has_keep_clear()) {
    clear_has_config();
    ::apollo::planning::KeepClearConfig* temp = config_.keep_clear_;
    config_.keep_clear_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrafficRuleConfig::unsafe_arena_set_allocated_keep_clear(::apollo::planning::KeepClearConfig* keep_clear) {
  clear_config();
  if (keep_clear) {
    set_has_keep_clear();
    config_.keep_clear_ = keep_clear;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.TrafficRuleConfig.keep_clear)
}
inline ::apollo::planning::KeepClearConfig* TrafficRuleConfig::_internal_mutable_keep_clear() {
  if (!_internal_has_keep_clear()) {
    clear_config();
    set_has_keep_clear();
    config_.keep_clear_ = CreateMaybeMessage< ::apollo::planning::KeepClearConfig >(GetArena());
  }
  return config_.keep_clear_;
}
inline ::apollo::planning::KeepClearConfig* TrafficRuleConfig::mutable_keep_clear() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.keep_clear)
  return _internal_mutable_keep_clear();
}

// .apollo.planning.ReferenceLineEndConfig reference_line_end = 7;
inline bool TrafficRuleConfig::_internal_has_reference_line_end() const {
  return config_case() == kReferenceLineEnd;
}
inline bool TrafficRuleConfig::has_reference_line_end() const {
  return _internal_has_reference_line_end();
}
inline void TrafficRuleConfig::set_has_reference_line_end() {
  _oneof_case_[0] = kReferenceLineEnd;
}
inline void TrafficRuleConfig::clear_reference_line_end() {
  if (_internal_has_reference_line_end()) {
    if (GetArena() == nullptr) {
      delete config_.reference_line_end_;
    }
    clear_has_config();
  }
}
inline ::apollo::planning::ReferenceLineEndConfig* TrafficRuleConfig::release_reference_line_end() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.reference_line_end)
  if (_internal_has_reference_line_end()) {
    clear_has_config();
      ::apollo::planning::ReferenceLineEndConfig* temp = config_.reference_line_end_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    config_.reference_line_end_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::ReferenceLineEndConfig& TrafficRuleConfig::_internal_reference_line_end() const {
  return _internal_has_reference_line_end()
      ? *config_.reference_line_end_
      : reinterpret_cast< ::apollo::planning::ReferenceLineEndConfig&>(::apollo::planning::_ReferenceLineEndConfig_default_instance_);
}
inline const ::apollo::planning::ReferenceLineEndConfig& TrafficRuleConfig::reference_line_end() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.reference_line_end)
  return _internal_reference_line_end();
}
inline ::apollo::planning::ReferenceLineEndConfig* TrafficRuleConfig::unsafe_arena_release_reference_line_end() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.planning.TrafficRuleConfig.reference_line_end)
  if (_internal_has_reference_line_end()) {
    clear_has_config();
    ::apollo::planning::ReferenceLineEndConfig* temp = config_.reference_line_end_;
    config_.reference_line_end_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrafficRuleConfig::unsafe_arena_set_allocated_reference_line_end(::apollo::planning::ReferenceLineEndConfig* reference_line_end) {
  clear_config();
  if (reference_line_end) {
    set_has_reference_line_end();
    config_.reference_line_end_ = reference_line_end;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.TrafficRuleConfig.reference_line_end)
}
inline ::apollo::planning::ReferenceLineEndConfig* TrafficRuleConfig::_internal_mutable_reference_line_end() {
  if (!_internal_has_reference_line_end()) {
    clear_config();
    set_has_reference_line_end();
    config_.reference_line_end_ = CreateMaybeMessage< ::apollo::planning::ReferenceLineEndConfig >(GetArena());
  }
  return config_.reference_line_end_;
}
inline ::apollo::planning::ReferenceLineEndConfig* TrafficRuleConfig::mutable_reference_line_end() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.reference_line_end)
  return _internal_mutable_reference_line_end();
}

// .apollo.planning.ReroutingConfig rerouting = 8;
inline bool TrafficRuleConfig::_internal_has_rerouting() const {
  return config_case() == kRerouting;
}
inline bool TrafficRuleConfig::has_rerouting() const {
  return _internal_has_rerouting();
}
inline void TrafficRuleConfig::set_has_rerouting() {
  _oneof_case_[0] = kRerouting;
}
inline void TrafficRuleConfig::clear_rerouting() {
  if (_internal_has_rerouting()) {
    if (GetArena() == nullptr) {
      delete config_.rerouting_;
    }
    clear_has_config();
  }
}
inline ::apollo::planning::ReroutingConfig* TrafficRuleConfig::release_rerouting() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.rerouting)
  if (_internal_has_rerouting()) {
    clear_has_config();
      ::apollo::planning::ReroutingConfig* temp = config_.rerouting_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    config_.rerouting_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::ReroutingConfig& TrafficRuleConfig::_internal_rerouting() const {
  return _internal_has_rerouting()
      ? *config_.rerouting_
      : reinterpret_cast< ::apollo::planning::ReroutingConfig&>(::apollo::planning::_ReroutingConfig_default_instance_);
}
inline const ::apollo::planning::ReroutingConfig& TrafficRuleConfig::rerouting() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.rerouting)
  return _internal_rerouting();
}
inline ::apollo::planning::ReroutingConfig* TrafficRuleConfig::unsafe_arena_release_rerouting() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.planning.TrafficRuleConfig.rerouting)
  if (_internal_has_rerouting()) {
    clear_has_config();
    ::apollo::planning::ReroutingConfig* temp = config_.rerouting_;
    config_.rerouting_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrafficRuleConfig::unsafe_arena_set_allocated_rerouting(::apollo::planning::ReroutingConfig* rerouting) {
  clear_config();
  if (rerouting) {
    set_has_rerouting();
    config_.rerouting_ = rerouting;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.TrafficRuleConfig.rerouting)
}
inline ::apollo::planning::ReroutingConfig* TrafficRuleConfig::_internal_mutable_rerouting() {
  if (!_internal_has_rerouting()) {
    clear_config();
    set_has_rerouting();
    config_.rerouting_ = CreateMaybeMessage< ::apollo::planning::ReroutingConfig >(GetArena());
  }
  return config_.rerouting_;
}
inline ::apollo::planning::ReroutingConfig* TrafficRuleConfig::mutable_rerouting() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.rerouting)
  return _internal_mutable_rerouting();
}

// .apollo.planning.StopSignConfig stop_sign = 9;
inline bool TrafficRuleConfig::_internal_has_stop_sign() const {
  return config_case() == kStopSign;
}
inline bool TrafficRuleConfig::has_stop_sign() const {
  return _internal_has_stop_sign();
}
inline void TrafficRuleConfig::set_has_stop_sign() {
  _oneof_case_[0] = kStopSign;
}
inline void TrafficRuleConfig::clear_stop_sign() {
  if (_internal_has_stop_sign()) {
    if (GetArena() == nullptr) {
      delete config_.stop_sign_;
    }
    clear_has_config();
  }
}
inline ::apollo::planning::StopSignConfig* TrafficRuleConfig::release_stop_sign() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.stop_sign)
  if (_internal_has_stop_sign()) {
    clear_has_config();
      ::apollo::planning::StopSignConfig* temp = config_.stop_sign_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    config_.stop_sign_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::StopSignConfig& TrafficRuleConfig::_internal_stop_sign() const {
  return _internal_has_stop_sign()
      ? *config_.stop_sign_
      : reinterpret_cast< ::apollo::planning::StopSignConfig&>(::apollo::planning::_StopSignConfig_default_instance_);
}
inline const ::apollo::planning::StopSignConfig& TrafficRuleConfig::stop_sign() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.stop_sign)
  return _internal_stop_sign();
}
inline ::apollo::planning::StopSignConfig* TrafficRuleConfig::unsafe_arena_release_stop_sign() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.planning.TrafficRuleConfig.stop_sign)
  if (_internal_has_stop_sign()) {
    clear_has_config();
    ::apollo::planning::StopSignConfig* temp = config_.stop_sign_;
    config_.stop_sign_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrafficRuleConfig::unsafe_arena_set_allocated_stop_sign(::apollo::planning::StopSignConfig* stop_sign) {
  clear_config();
  if (stop_sign) {
    set_has_stop_sign();
    config_.stop_sign_ = stop_sign;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.TrafficRuleConfig.stop_sign)
}
inline ::apollo::planning::StopSignConfig* TrafficRuleConfig::_internal_mutable_stop_sign() {
  if (!_internal_has_stop_sign()) {
    clear_config();
    set_has_stop_sign();
    config_.stop_sign_ = CreateMaybeMessage< ::apollo::planning::StopSignConfig >(GetArena());
  }
  return config_.stop_sign_;
}
inline ::apollo::planning::StopSignConfig* TrafficRuleConfig::mutable_stop_sign() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.stop_sign)
  return _internal_mutable_stop_sign();
}

// .apollo.planning.TrafficLightConfig traffic_light = 10;
inline bool TrafficRuleConfig::_internal_has_traffic_light() const {
  return config_case() == kTrafficLight;
}
inline bool TrafficRuleConfig::has_traffic_light() const {
  return _internal_has_traffic_light();
}
inline void TrafficRuleConfig::set_has_traffic_light() {
  _oneof_case_[0] = kTrafficLight;
}
inline void TrafficRuleConfig::clear_traffic_light() {
  if (_internal_has_traffic_light()) {
    if (GetArena() == nullptr) {
      delete config_.traffic_light_;
    }
    clear_has_config();
  }
}
inline ::apollo::planning::TrafficLightConfig* TrafficRuleConfig::release_traffic_light() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.traffic_light)
  if (_internal_has_traffic_light()) {
    clear_has_config();
      ::apollo::planning::TrafficLightConfig* temp = config_.traffic_light_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    config_.traffic_light_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::TrafficLightConfig& TrafficRuleConfig::_internal_traffic_light() const {
  return _internal_has_traffic_light()
      ? *config_.traffic_light_
      : reinterpret_cast< ::apollo::planning::TrafficLightConfig&>(::apollo::planning::_TrafficLightConfig_default_instance_);
}
inline const ::apollo::planning::TrafficLightConfig& TrafficRuleConfig::traffic_light() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.traffic_light)
  return _internal_traffic_light();
}
inline ::apollo::planning::TrafficLightConfig* TrafficRuleConfig::unsafe_arena_release_traffic_light() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.planning.TrafficRuleConfig.traffic_light)
  if (_internal_has_traffic_light()) {
    clear_has_config();
    ::apollo::planning::TrafficLightConfig* temp = config_.traffic_light_;
    config_.traffic_light_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrafficRuleConfig::unsafe_arena_set_allocated_traffic_light(::apollo::planning::TrafficLightConfig* traffic_light) {
  clear_config();
  if (traffic_light) {
    set_has_traffic_light();
    config_.traffic_light_ = traffic_light;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.TrafficRuleConfig.traffic_light)
}
inline ::apollo::planning::TrafficLightConfig* TrafficRuleConfig::_internal_mutable_traffic_light() {
  if (!_internal_has_traffic_light()) {
    clear_config();
    set_has_traffic_light();
    config_.traffic_light_ = CreateMaybeMessage< ::apollo::planning::TrafficLightConfig >(GetArena());
  }
  return config_.traffic_light_;
}
inline ::apollo::planning::TrafficLightConfig* TrafficRuleConfig::mutable_traffic_light() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.traffic_light)
  return _internal_mutable_traffic_light();
}

// .apollo.planning.YieldSignConfig yield_sign = 11;
inline bool TrafficRuleConfig::_internal_has_yield_sign() const {
  return config_case() == kYieldSign;
}
inline bool TrafficRuleConfig::has_yield_sign() const {
  return _internal_has_yield_sign();
}
inline void TrafficRuleConfig::set_has_yield_sign() {
  _oneof_case_[0] = kYieldSign;
}
inline void TrafficRuleConfig::clear_yield_sign() {
  if (_internal_has_yield_sign()) {
    if (GetArena() == nullptr) {
      delete config_.yield_sign_;
    }
    clear_has_config();
  }
}
inline ::apollo::planning::YieldSignConfig* TrafficRuleConfig::release_yield_sign() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.yield_sign)
  if (_internal_has_yield_sign()) {
    clear_has_config();
      ::apollo::planning::YieldSignConfig* temp = config_.yield_sign_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    config_.yield_sign_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::planning::YieldSignConfig& TrafficRuleConfig::_internal_yield_sign() const {
  return _internal_has_yield_sign()
      ? *config_.yield_sign_
      : reinterpret_cast< ::apollo::planning::YieldSignConfig&>(::apollo::planning::_YieldSignConfig_default_instance_);
}
inline const ::apollo::planning::YieldSignConfig& TrafficRuleConfig::yield_sign() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.yield_sign)
  return _internal_yield_sign();
}
inline ::apollo::planning::YieldSignConfig* TrafficRuleConfig::unsafe_arena_release_yield_sign() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.planning.TrafficRuleConfig.yield_sign)
  if (_internal_has_yield_sign()) {
    clear_has_config();
    ::apollo::planning::YieldSignConfig* temp = config_.yield_sign_;
    config_.yield_sign_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TrafficRuleConfig::unsafe_arena_set_allocated_yield_sign(::apollo::planning::YieldSignConfig* yield_sign) {
  clear_config();
  if (yield_sign) {
    set_has_yield_sign();
    config_.yield_sign_ = yield_sign;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.planning.TrafficRuleConfig.yield_sign)
}
inline ::apollo::planning::YieldSignConfig* TrafficRuleConfig::_internal_mutable_yield_sign() {
  if (!_internal_has_yield_sign()) {
    clear_config();
    set_has_yield_sign();
    config_.yield_sign_ = CreateMaybeMessage< ::apollo::planning::YieldSignConfig >(GetArena());
  }
  return config_.yield_sign_;
}
inline ::apollo::planning::YieldSignConfig* TrafficRuleConfig::mutable_yield_sign() {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.yield_sign)
  return _internal_mutable_yield_sign();
}

inline bool TrafficRuleConfig::has_config() const {
  return config_case() != CONFIG_NOT_SET;
}
inline void TrafficRuleConfig::clear_has_config() {
  _oneof_case_[0] = CONFIG_NOT_SET;
}
inline TrafficRuleConfig::ConfigCase TrafficRuleConfig::config_case() const {
  return TrafficRuleConfig::ConfigCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TrafficRuleConfigs

// repeated .apollo.planning.TrafficRuleConfig config = 1;
inline int TrafficRuleConfigs::_internal_config_size() const {
  return config_.size();
}
inline int TrafficRuleConfigs::config_size() const {
  return _internal_config_size();
}
inline void TrafficRuleConfigs::clear_config() {
  config_.Clear();
}
inline ::apollo::planning::TrafficRuleConfig* TrafficRuleConfigs::mutable_config(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfigs.config)
  return config_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TrafficRuleConfig >*
TrafficRuleConfigs::mutable_config() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.TrafficRuleConfigs.config)
  return &config_;
}
inline const ::apollo::planning::TrafficRuleConfig& TrafficRuleConfigs::_internal_config(int index) const {
  return config_.Get(index);
}
inline const ::apollo::planning::TrafficRuleConfig& TrafficRuleConfigs::config(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfigs.config)
  return _internal_config(index);
}
inline ::apollo::planning::TrafficRuleConfig* TrafficRuleConfigs::_internal_add_config() {
  return config_.Add();
}
inline ::apollo::planning::TrafficRuleConfig* TrafficRuleConfigs::add_config() {
  // @@protoc_insertion_point(field_add:apollo.planning.TrafficRuleConfigs.config)
  return _internal_add_config();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::planning::TrafficRuleConfig >&
TrafficRuleConfigs::config() const {
  // @@protoc_insertion_point(field_list:apollo.planning.TrafficRuleConfigs.config)
  return config_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace planning
}  // namespace apollo

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::apollo::planning::TrafficRuleConfig_RuleId> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::planning::TrafficRuleConfig_RuleId>() {
  return ::apollo::planning::TrafficRuleConfig_RuleId_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_modules_2fplanning_2fproto_2ftraffic_5frule_5fconfig_2eproto
