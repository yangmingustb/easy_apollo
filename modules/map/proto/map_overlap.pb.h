// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/map/proto/map_overlap.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_modules_2fmap_2fproto_2fmap_5foverlap_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_modules_2fmap_2fproto_2fmap_5foverlap_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "modules/map/proto/map_id.pb.h"
#include "modules/map/proto/map_geometry.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_modules_2fmap_2fproto_2fmap_5foverlap_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_modules_2fmap_2fproto_2fmap_5foverlap_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto;
namespace apollo {
namespace hdmap {
class ClearAreaOverlapInfo;
class ClearAreaOverlapInfoDefaultTypeInternal;
extern ClearAreaOverlapInfoDefaultTypeInternal _ClearAreaOverlapInfo_default_instance_;
class CrosswalkOverlapInfo;
class CrosswalkOverlapInfoDefaultTypeInternal;
extern CrosswalkOverlapInfoDefaultTypeInternal _CrosswalkOverlapInfo_default_instance_;
class JunctionOverlapInfo;
class JunctionOverlapInfoDefaultTypeInternal;
extern JunctionOverlapInfoDefaultTypeInternal _JunctionOverlapInfo_default_instance_;
class LaneOverlapInfo;
class LaneOverlapInfoDefaultTypeInternal;
extern LaneOverlapInfoDefaultTypeInternal _LaneOverlapInfo_default_instance_;
class ObjectOverlapInfo;
class ObjectOverlapInfoDefaultTypeInternal;
extern ObjectOverlapInfoDefaultTypeInternal _ObjectOverlapInfo_default_instance_;
class Overlap;
class OverlapDefaultTypeInternal;
extern OverlapDefaultTypeInternal _Overlap_default_instance_;
class PNCJunctionOverlapInfo;
class PNCJunctionOverlapInfoDefaultTypeInternal;
extern PNCJunctionOverlapInfoDefaultTypeInternal _PNCJunctionOverlapInfo_default_instance_;
class ParkingSpaceOverlapInfo;
class ParkingSpaceOverlapInfoDefaultTypeInternal;
extern ParkingSpaceOverlapInfoDefaultTypeInternal _ParkingSpaceOverlapInfo_default_instance_;
class RSUOverlapInfo;
class RSUOverlapInfoDefaultTypeInternal;
extern RSUOverlapInfoDefaultTypeInternal _RSUOverlapInfo_default_instance_;
class RegionOverlapInfo;
class RegionOverlapInfoDefaultTypeInternal;
extern RegionOverlapInfoDefaultTypeInternal _RegionOverlapInfo_default_instance_;
class SignalOverlapInfo;
class SignalOverlapInfoDefaultTypeInternal;
extern SignalOverlapInfoDefaultTypeInternal _SignalOverlapInfo_default_instance_;
class SpeedBumpOverlapInfo;
class SpeedBumpOverlapInfoDefaultTypeInternal;
extern SpeedBumpOverlapInfoDefaultTypeInternal _SpeedBumpOverlapInfo_default_instance_;
class StopSignOverlapInfo;
class StopSignOverlapInfoDefaultTypeInternal;
extern StopSignOverlapInfoDefaultTypeInternal _StopSignOverlapInfo_default_instance_;
class YieldOverlapInfo;
class YieldOverlapInfoDefaultTypeInternal;
extern YieldOverlapInfoDefaultTypeInternal _YieldOverlapInfo_default_instance_;
}  // namespace hdmap
}  // namespace apollo
PROTOBUF_NAMESPACE_OPEN
template<> ::apollo::hdmap::ClearAreaOverlapInfo* Arena::CreateMaybeMessage<::apollo::hdmap::ClearAreaOverlapInfo>(Arena*);
template<> ::apollo::hdmap::CrosswalkOverlapInfo* Arena::CreateMaybeMessage<::apollo::hdmap::CrosswalkOverlapInfo>(Arena*);
template<> ::apollo::hdmap::JunctionOverlapInfo* Arena::CreateMaybeMessage<::apollo::hdmap::JunctionOverlapInfo>(Arena*);
template<> ::apollo::hdmap::LaneOverlapInfo* Arena::CreateMaybeMessage<::apollo::hdmap::LaneOverlapInfo>(Arena*);
template<> ::apollo::hdmap::ObjectOverlapInfo* Arena::CreateMaybeMessage<::apollo::hdmap::ObjectOverlapInfo>(Arena*);
template<> ::apollo::hdmap::Overlap* Arena::CreateMaybeMessage<::apollo::hdmap::Overlap>(Arena*);
template<> ::apollo::hdmap::PNCJunctionOverlapInfo* Arena::CreateMaybeMessage<::apollo::hdmap::PNCJunctionOverlapInfo>(Arena*);
template<> ::apollo::hdmap::ParkingSpaceOverlapInfo* Arena::CreateMaybeMessage<::apollo::hdmap::ParkingSpaceOverlapInfo>(Arena*);
template<> ::apollo::hdmap::RSUOverlapInfo* Arena::CreateMaybeMessage<::apollo::hdmap::RSUOverlapInfo>(Arena*);
template<> ::apollo::hdmap::RegionOverlapInfo* Arena::CreateMaybeMessage<::apollo::hdmap::RegionOverlapInfo>(Arena*);
template<> ::apollo::hdmap::SignalOverlapInfo* Arena::CreateMaybeMessage<::apollo::hdmap::SignalOverlapInfo>(Arena*);
template<> ::apollo::hdmap::SpeedBumpOverlapInfo* Arena::CreateMaybeMessage<::apollo::hdmap::SpeedBumpOverlapInfo>(Arena*);
template<> ::apollo::hdmap::StopSignOverlapInfo* Arena::CreateMaybeMessage<::apollo::hdmap::StopSignOverlapInfo>(Arena*);
template<> ::apollo::hdmap::YieldOverlapInfo* Arena::CreateMaybeMessage<::apollo::hdmap::YieldOverlapInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace apollo {
namespace hdmap {

// ===================================================================

class LaneOverlapInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.hdmap.LaneOverlapInfo) */ {
 public:
  inline LaneOverlapInfo() : LaneOverlapInfo(nullptr) {}
  virtual ~LaneOverlapInfo();

  LaneOverlapInfo(const LaneOverlapInfo& from);
  LaneOverlapInfo(LaneOverlapInfo&& from) noexcept
    : LaneOverlapInfo() {
    *this = ::std::move(from);
  }

  inline LaneOverlapInfo& operator=(const LaneOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline LaneOverlapInfo& operator=(LaneOverlapInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LaneOverlapInfo& default_instance();

  static inline const LaneOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const LaneOverlapInfo*>(
               &_LaneOverlapInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LaneOverlapInfo& a, LaneOverlapInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(LaneOverlapInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LaneOverlapInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LaneOverlapInfo* New() const final {
    return CreateMaybeMessage<LaneOverlapInfo>(nullptr);
  }

  LaneOverlapInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LaneOverlapInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LaneOverlapInfo& from);
  void MergeFrom(const LaneOverlapInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneOverlapInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.hdmap.LaneOverlapInfo";
  }
  protected:
  explicit LaneOverlapInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto);
    return ::descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionOverlapIdFieldNumber = 4,
    kStartSFieldNumber = 1,
    kEndSFieldNumber = 2,
    kIsMergeFieldNumber = 3,
  };
  // optional .apollo.hdmap.Id region_overlap_id = 4;
  bool has_region_overlap_id() const;
  private:
  bool _internal_has_region_overlap_id() const;
  public:
  void clear_region_overlap_id();
  const ::apollo::hdmap::Id& region_overlap_id() const;
  ::apollo::hdmap::Id* release_region_overlap_id();
  ::apollo::hdmap::Id* mutable_region_overlap_id();
  void set_allocated_region_overlap_id(::apollo::hdmap::Id* region_overlap_id);
  private:
  const ::apollo::hdmap::Id& _internal_region_overlap_id() const;
  ::apollo::hdmap::Id* _internal_mutable_region_overlap_id();
  public:
  void unsafe_arena_set_allocated_region_overlap_id(
      ::apollo::hdmap::Id* region_overlap_id);
  ::apollo::hdmap::Id* unsafe_arena_release_region_overlap_id();

  // optional double start_s = 1;
  bool has_start_s() const;
  private:
  bool _internal_has_start_s() const;
  public:
  void clear_start_s();
  double start_s() const;
  void set_start_s(double value);
  private:
  double _internal_start_s() const;
  void _internal_set_start_s(double value);
  public:

  // optional double end_s = 2;
  bool has_end_s() const;
  private:
  bool _internal_has_end_s() const;
  public:
  void clear_end_s();
  double end_s() const;
  void set_end_s(double value);
  private:
  double _internal_end_s() const;
  void _internal_set_end_s(double value);
  public:

  // optional bool is_merge = 3;
  bool has_is_merge() const;
  private:
  bool _internal_has_is_merge() const;
  public:
  void clear_is_merge();
  bool is_merge() const;
  void set_is_merge(bool value);
  private:
  bool _internal_is_merge() const;
  void _internal_set_is_merge(bool value);
  public:

  // @@protoc_insertion_point(class_scope:apollo.hdmap.LaneOverlapInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::apollo::hdmap::Id* region_overlap_id_;
  double start_s_;
  double end_s_;
  bool is_merge_;
  friend struct ::TableStruct_modules_2fmap_2fproto_2fmap_5foverlap_2eproto;
};
// -------------------------------------------------------------------

class SignalOverlapInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.hdmap.SignalOverlapInfo) */ {
 public:
  inline SignalOverlapInfo() : SignalOverlapInfo(nullptr) {}
  virtual ~SignalOverlapInfo();

  SignalOverlapInfo(const SignalOverlapInfo& from);
  SignalOverlapInfo(SignalOverlapInfo&& from) noexcept
    : SignalOverlapInfo() {
    *this = ::std::move(from);
  }

  inline SignalOverlapInfo& operator=(const SignalOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignalOverlapInfo& operator=(SignalOverlapInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SignalOverlapInfo& default_instance();

  static inline const SignalOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const SignalOverlapInfo*>(
               &_SignalOverlapInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SignalOverlapInfo& a, SignalOverlapInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SignalOverlapInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignalOverlapInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SignalOverlapInfo* New() const final {
    return CreateMaybeMessage<SignalOverlapInfo>(nullptr);
  }

  SignalOverlapInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SignalOverlapInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SignalOverlapInfo& from);
  void MergeFrom(const SignalOverlapInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalOverlapInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.hdmap.SignalOverlapInfo";
  }
  protected:
  explicit SignalOverlapInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto);
    return ::descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.hdmap.SignalOverlapInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fmap_2fproto_2fmap_5foverlap_2eproto;
};
// -------------------------------------------------------------------

class StopSignOverlapInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.hdmap.StopSignOverlapInfo) */ {
 public:
  inline StopSignOverlapInfo() : StopSignOverlapInfo(nullptr) {}
  virtual ~StopSignOverlapInfo();

  StopSignOverlapInfo(const StopSignOverlapInfo& from);
  StopSignOverlapInfo(StopSignOverlapInfo&& from) noexcept
    : StopSignOverlapInfo() {
    *this = ::std::move(from);
  }

  inline StopSignOverlapInfo& operator=(const StopSignOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopSignOverlapInfo& operator=(StopSignOverlapInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StopSignOverlapInfo& default_instance();

  static inline const StopSignOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const StopSignOverlapInfo*>(
               &_StopSignOverlapInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StopSignOverlapInfo& a, StopSignOverlapInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(StopSignOverlapInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopSignOverlapInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StopSignOverlapInfo* New() const final {
    return CreateMaybeMessage<StopSignOverlapInfo>(nullptr);
  }

  StopSignOverlapInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StopSignOverlapInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StopSignOverlapInfo& from);
  void MergeFrom(const StopSignOverlapInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopSignOverlapInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.hdmap.StopSignOverlapInfo";
  }
  protected:
  explicit StopSignOverlapInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto);
    return ::descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.hdmap.StopSignOverlapInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fmap_2fproto_2fmap_5foverlap_2eproto;
};
// -------------------------------------------------------------------

class CrosswalkOverlapInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.hdmap.CrosswalkOverlapInfo) */ {
 public:
  inline CrosswalkOverlapInfo() : CrosswalkOverlapInfo(nullptr) {}
  virtual ~CrosswalkOverlapInfo();

  CrosswalkOverlapInfo(const CrosswalkOverlapInfo& from);
  CrosswalkOverlapInfo(CrosswalkOverlapInfo&& from) noexcept
    : CrosswalkOverlapInfo() {
    *this = ::std::move(from);
  }

  inline CrosswalkOverlapInfo& operator=(const CrosswalkOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CrosswalkOverlapInfo& operator=(CrosswalkOverlapInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CrosswalkOverlapInfo& default_instance();

  static inline const CrosswalkOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const CrosswalkOverlapInfo*>(
               &_CrosswalkOverlapInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CrosswalkOverlapInfo& a, CrosswalkOverlapInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CrosswalkOverlapInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CrosswalkOverlapInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CrosswalkOverlapInfo* New() const final {
    return CreateMaybeMessage<CrosswalkOverlapInfo>(nullptr);
  }

  CrosswalkOverlapInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CrosswalkOverlapInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CrosswalkOverlapInfo& from);
  void MergeFrom(const CrosswalkOverlapInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CrosswalkOverlapInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.hdmap.CrosswalkOverlapInfo";
  }
  protected:
  explicit CrosswalkOverlapInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto);
    return ::descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionOverlapIdFieldNumber = 1,
  };
  // optional .apollo.hdmap.Id region_overlap_id = 1;
  bool has_region_overlap_id() const;
  private:
  bool _internal_has_region_overlap_id() const;
  public:
  void clear_region_overlap_id();
  const ::apollo::hdmap::Id& region_overlap_id() const;
  ::apollo::hdmap::Id* release_region_overlap_id();
  ::apollo::hdmap::Id* mutable_region_overlap_id();
  void set_allocated_region_overlap_id(::apollo::hdmap::Id* region_overlap_id);
  private:
  const ::apollo::hdmap::Id& _internal_region_overlap_id() const;
  ::apollo::hdmap::Id* _internal_mutable_region_overlap_id();
  public:
  void unsafe_arena_set_allocated_region_overlap_id(
      ::apollo::hdmap::Id* region_overlap_id);
  ::apollo::hdmap::Id* unsafe_arena_release_region_overlap_id();

  // @@protoc_insertion_point(class_scope:apollo.hdmap.CrosswalkOverlapInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::apollo::hdmap::Id* region_overlap_id_;
  friend struct ::TableStruct_modules_2fmap_2fproto_2fmap_5foverlap_2eproto;
};
// -------------------------------------------------------------------

class JunctionOverlapInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.hdmap.JunctionOverlapInfo) */ {
 public:
  inline JunctionOverlapInfo() : JunctionOverlapInfo(nullptr) {}
  virtual ~JunctionOverlapInfo();

  JunctionOverlapInfo(const JunctionOverlapInfo& from);
  JunctionOverlapInfo(JunctionOverlapInfo&& from) noexcept
    : JunctionOverlapInfo() {
    *this = ::std::move(from);
  }

  inline JunctionOverlapInfo& operator=(const JunctionOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline JunctionOverlapInfo& operator=(JunctionOverlapInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const JunctionOverlapInfo& default_instance();

  static inline const JunctionOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const JunctionOverlapInfo*>(
               &_JunctionOverlapInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(JunctionOverlapInfo& a, JunctionOverlapInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(JunctionOverlapInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JunctionOverlapInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline JunctionOverlapInfo* New() const final {
    return CreateMaybeMessage<JunctionOverlapInfo>(nullptr);
  }

  JunctionOverlapInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<JunctionOverlapInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const JunctionOverlapInfo& from);
  void MergeFrom(const JunctionOverlapInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JunctionOverlapInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.hdmap.JunctionOverlapInfo";
  }
  protected:
  explicit JunctionOverlapInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto);
    return ::descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.hdmap.JunctionOverlapInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fmap_2fproto_2fmap_5foverlap_2eproto;
};
// -------------------------------------------------------------------

class YieldOverlapInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.hdmap.YieldOverlapInfo) */ {
 public:
  inline YieldOverlapInfo() : YieldOverlapInfo(nullptr) {}
  virtual ~YieldOverlapInfo();

  YieldOverlapInfo(const YieldOverlapInfo& from);
  YieldOverlapInfo(YieldOverlapInfo&& from) noexcept
    : YieldOverlapInfo() {
    *this = ::std::move(from);
  }

  inline YieldOverlapInfo& operator=(const YieldOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline YieldOverlapInfo& operator=(YieldOverlapInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const YieldOverlapInfo& default_instance();

  static inline const YieldOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const YieldOverlapInfo*>(
               &_YieldOverlapInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(YieldOverlapInfo& a, YieldOverlapInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(YieldOverlapInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(YieldOverlapInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline YieldOverlapInfo* New() const final {
    return CreateMaybeMessage<YieldOverlapInfo>(nullptr);
  }

  YieldOverlapInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<YieldOverlapInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const YieldOverlapInfo& from);
  void MergeFrom(const YieldOverlapInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(YieldOverlapInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.hdmap.YieldOverlapInfo";
  }
  protected:
  explicit YieldOverlapInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto);
    return ::descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.hdmap.YieldOverlapInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fmap_2fproto_2fmap_5foverlap_2eproto;
};
// -------------------------------------------------------------------

class ClearAreaOverlapInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.hdmap.ClearAreaOverlapInfo) */ {
 public:
  inline ClearAreaOverlapInfo() : ClearAreaOverlapInfo(nullptr) {}
  virtual ~ClearAreaOverlapInfo();

  ClearAreaOverlapInfo(const ClearAreaOverlapInfo& from);
  ClearAreaOverlapInfo(ClearAreaOverlapInfo&& from) noexcept
    : ClearAreaOverlapInfo() {
    *this = ::std::move(from);
  }

  inline ClearAreaOverlapInfo& operator=(const ClearAreaOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearAreaOverlapInfo& operator=(ClearAreaOverlapInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClearAreaOverlapInfo& default_instance();

  static inline const ClearAreaOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const ClearAreaOverlapInfo*>(
               &_ClearAreaOverlapInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ClearAreaOverlapInfo& a, ClearAreaOverlapInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ClearAreaOverlapInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearAreaOverlapInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClearAreaOverlapInfo* New() const final {
    return CreateMaybeMessage<ClearAreaOverlapInfo>(nullptr);
  }

  ClearAreaOverlapInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClearAreaOverlapInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClearAreaOverlapInfo& from);
  void MergeFrom(const ClearAreaOverlapInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClearAreaOverlapInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.hdmap.ClearAreaOverlapInfo";
  }
  protected:
  explicit ClearAreaOverlapInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto);
    return ::descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.hdmap.ClearAreaOverlapInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fmap_2fproto_2fmap_5foverlap_2eproto;
};
// -------------------------------------------------------------------

class SpeedBumpOverlapInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.hdmap.SpeedBumpOverlapInfo) */ {
 public:
  inline SpeedBumpOverlapInfo() : SpeedBumpOverlapInfo(nullptr) {}
  virtual ~SpeedBumpOverlapInfo();

  SpeedBumpOverlapInfo(const SpeedBumpOverlapInfo& from);
  SpeedBumpOverlapInfo(SpeedBumpOverlapInfo&& from) noexcept
    : SpeedBumpOverlapInfo() {
    *this = ::std::move(from);
  }

  inline SpeedBumpOverlapInfo& operator=(const SpeedBumpOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpeedBumpOverlapInfo& operator=(SpeedBumpOverlapInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpeedBumpOverlapInfo& default_instance();

  static inline const SpeedBumpOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const SpeedBumpOverlapInfo*>(
               &_SpeedBumpOverlapInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SpeedBumpOverlapInfo& a, SpeedBumpOverlapInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SpeedBumpOverlapInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpeedBumpOverlapInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpeedBumpOverlapInfo* New() const final {
    return CreateMaybeMessage<SpeedBumpOverlapInfo>(nullptr);
  }

  SpeedBumpOverlapInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpeedBumpOverlapInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpeedBumpOverlapInfo& from);
  void MergeFrom(const SpeedBumpOverlapInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpeedBumpOverlapInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.hdmap.SpeedBumpOverlapInfo";
  }
  protected:
  explicit SpeedBumpOverlapInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto);
    return ::descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.hdmap.SpeedBumpOverlapInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fmap_2fproto_2fmap_5foverlap_2eproto;
};
// -------------------------------------------------------------------

class ParkingSpaceOverlapInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.hdmap.ParkingSpaceOverlapInfo) */ {
 public:
  inline ParkingSpaceOverlapInfo() : ParkingSpaceOverlapInfo(nullptr) {}
  virtual ~ParkingSpaceOverlapInfo();

  ParkingSpaceOverlapInfo(const ParkingSpaceOverlapInfo& from);
  ParkingSpaceOverlapInfo(ParkingSpaceOverlapInfo&& from) noexcept
    : ParkingSpaceOverlapInfo() {
    *this = ::std::move(from);
  }

  inline ParkingSpaceOverlapInfo& operator=(const ParkingSpaceOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParkingSpaceOverlapInfo& operator=(ParkingSpaceOverlapInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ParkingSpaceOverlapInfo& default_instance();

  static inline const ParkingSpaceOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const ParkingSpaceOverlapInfo*>(
               &_ParkingSpaceOverlapInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ParkingSpaceOverlapInfo& a, ParkingSpaceOverlapInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ParkingSpaceOverlapInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParkingSpaceOverlapInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ParkingSpaceOverlapInfo* New() const final {
    return CreateMaybeMessage<ParkingSpaceOverlapInfo>(nullptr);
  }

  ParkingSpaceOverlapInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ParkingSpaceOverlapInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ParkingSpaceOverlapInfo& from);
  void MergeFrom(const ParkingSpaceOverlapInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParkingSpaceOverlapInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.hdmap.ParkingSpaceOverlapInfo";
  }
  protected:
  explicit ParkingSpaceOverlapInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto);
    return ::descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.hdmap.ParkingSpaceOverlapInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fmap_2fproto_2fmap_5foverlap_2eproto;
};
// -------------------------------------------------------------------

class PNCJunctionOverlapInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.hdmap.PNCJunctionOverlapInfo) */ {
 public:
  inline PNCJunctionOverlapInfo() : PNCJunctionOverlapInfo(nullptr) {}
  virtual ~PNCJunctionOverlapInfo();

  PNCJunctionOverlapInfo(const PNCJunctionOverlapInfo& from);
  PNCJunctionOverlapInfo(PNCJunctionOverlapInfo&& from) noexcept
    : PNCJunctionOverlapInfo() {
    *this = ::std::move(from);
  }

  inline PNCJunctionOverlapInfo& operator=(const PNCJunctionOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PNCJunctionOverlapInfo& operator=(PNCJunctionOverlapInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PNCJunctionOverlapInfo& default_instance();

  static inline const PNCJunctionOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const PNCJunctionOverlapInfo*>(
               &_PNCJunctionOverlapInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PNCJunctionOverlapInfo& a, PNCJunctionOverlapInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PNCJunctionOverlapInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PNCJunctionOverlapInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PNCJunctionOverlapInfo* New() const final {
    return CreateMaybeMessage<PNCJunctionOverlapInfo>(nullptr);
  }

  PNCJunctionOverlapInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PNCJunctionOverlapInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PNCJunctionOverlapInfo& from);
  void MergeFrom(const PNCJunctionOverlapInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PNCJunctionOverlapInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.hdmap.PNCJunctionOverlapInfo";
  }
  protected:
  explicit PNCJunctionOverlapInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto);
    return ::descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.hdmap.PNCJunctionOverlapInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fmap_2fproto_2fmap_5foverlap_2eproto;
};
// -------------------------------------------------------------------

class RSUOverlapInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.hdmap.RSUOverlapInfo) */ {
 public:
  inline RSUOverlapInfo() : RSUOverlapInfo(nullptr) {}
  virtual ~RSUOverlapInfo();

  RSUOverlapInfo(const RSUOverlapInfo& from);
  RSUOverlapInfo(RSUOverlapInfo&& from) noexcept
    : RSUOverlapInfo() {
    *this = ::std::move(from);
  }

  inline RSUOverlapInfo& operator=(const RSUOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RSUOverlapInfo& operator=(RSUOverlapInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RSUOverlapInfo& default_instance();

  static inline const RSUOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const RSUOverlapInfo*>(
               &_RSUOverlapInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RSUOverlapInfo& a, RSUOverlapInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RSUOverlapInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RSUOverlapInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RSUOverlapInfo* New() const final {
    return CreateMaybeMessage<RSUOverlapInfo>(nullptr);
  }

  RSUOverlapInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RSUOverlapInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RSUOverlapInfo& from);
  void MergeFrom(const RSUOverlapInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RSUOverlapInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.hdmap.RSUOverlapInfo";
  }
  protected:
  explicit RSUOverlapInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto);
    return ::descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.hdmap.RSUOverlapInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_modules_2fmap_2fproto_2fmap_5foverlap_2eproto;
};
// -------------------------------------------------------------------

class RegionOverlapInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.hdmap.RegionOverlapInfo) */ {
 public:
  inline RegionOverlapInfo() : RegionOverlapInfo(nullptr) {}
  virtual ~RegionOverlapInfo();

  RegionOverlapInfo(const RegionOverlapInfo& from);
  RegionOverlapInfo(RegionOverlapInfo&& from) noexcept
    : RegionOverlapInfo() {
    *this = ::std::move(from);
  }

  inline RegionOverlapInfo& operator=(const RegionOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionOverlapInfo& operator=(RegionOverlapInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RegionOverlapInfo& default_instance();

  static inline const RegionOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const RegionOverlapInfo*>(
               &_RegionOverlapInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RegionOverlapInfo& a, RegionOverlapInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionOverlapInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegionOverlapInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegionOverlapInfo* New() const final {
    return CreateMaybeMessage<RegionOverlapInfo>(nullptr);
  }

  RegionOverlapInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegionOverlapInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RegionOverlapInfo& from);
  void MergeFrom(const RegionOverlapInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionOverlapInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.hdmap.RegionOverlapInfo";
  }
  protected:
  explicit RegionOverlapInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto);
    return ::descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPolygonFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated .apollo.hdmap.Polygon polygon = 2;
  int polygon_size() const;
  private:
  int _internal_polygon_size() const;
  public:
  void clear_polygon();
  ::apollo::hdmap::Polygon* mutable_polygon(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::hdmap::Polygon >*
      mutable_polygon();
  private:
  const ::apollo::hdmap::Polygon& _internal_polygon(int index) const;
  ::apollo::hdmap::Polygon* _internal_add_polygon();
  public:
  const ::apollo::hdmap::Polygon& polygon(int index) const;
  ::apollo::hdmap::Polygon* add_polygon();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::hdmap::Polygon >&
      polygon() const;

  // optional .apollo.hdmap.Id id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::apollo::hdmap::Id& id() const;
  ::apollo::hdmap::Id* release_id();
  ::apollo::hdmap::Id* mutable_id();
  void set_allocated_id(::apollo::hdmap::Id* id);
  private:
  const ::apollo::hdmap::Id& _internal_id() const;
  ::apollo::hdmap::Id* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::apollo::hdmap::Id* id);
  ::apollo::hdmap::Id* unsafe_arena_release_id();

  // @@protoc_insertion_point(class_scope:apollo.hdmap.RegionOverlapInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::hdmap::Polygon > polygon_;
  ::apollo::hdmap::Id* id_;
  friend struct ::TableStruct_modules_2fmap_2fproto_2fmap_5foverlap_2eproto;
};
// -------------------------------------------------------------------

class ObjectOverlapInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.hdmap.ObjectOverlapInfo) */ {
 public:
  inline ObjectOverlapInfo() : ObjectOverlapInfo(nullptr) {}
  virtual ~ObjectOverlapInfo();

  ObjectOverlapInfo(const ObjectOverlapInfo& from);
  ObjectOverlapInfo(ObjectOverlapInfo&& from) noexcept
    : ObjectOverlapInfo() {
    *this = ::std::move(from);
  }

  inline ObjectOverlapInfo& operator=(const ObjectOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObjectOverlapInfo& operator=(ObjectOverlapInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ObjectOverlapInfo& default_instance();

  enum OverlapInfoCase {
    kLaneOverlapInfo = 3,
    kSignalOverlapInfo = 4,
    kStopSignOverlapInfo = 5,
    kCrosswalkOverlapInfo = 6,
    kJunctionOverlapInfo = 7,
    kYieldSignOverlapInfo = 8,
    kClearAreaOverlapInfo = 9,
    kSpeedBumpOverlapInfo = 10,
    kParkingSpaceOverlapInfo = 11,
    kPncJunctionOverlapInfo = 12,
    kRsuOverlapInfo = 13,
    OVERLAP_INFO_NOT_SET = 0,
  };

  static inline const ObjectOverlapInfo* internal_default_instance() {
    return reinterpret_cast<const ObjectOverlapInfo*>(
               &_ObjectOverlapInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ObjectOverlapInfo& a, ObjectOverlapInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ObjectOverlapInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObjectOverlapInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ObjectOverlapInfo* New() const final {
    return CreateMaybeMessage<ObjectOverlapInfo>(nullptr);
  }

  ObjectOverlapInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ObjectOverlapInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ObjectOverlapInfo& from);
  void MergeFrom(const ObjectOverlapInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectOverlapInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.hdmap.ObjectOverlapInfo";
  }
  protected:
  explicit ObjectOverlapInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto);
    return ::descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kLaneOverlapInfoFieldNumber = 3,
    kSignalOverlapInfoFieldNumber = 4,
    kStopSignOverlapInfoFieldNumber = 5,
    kCrosswalkOverlapInfoFieldNumber = 6,
    kJunctionOverlapInfoFieldNumber = 7,
    kYieldSignOverlapInfoFieldNumber = 8,
    kClearAreaOverlapInfoFieldNumber = 9,
    kSpeedBumpOverlapInfoFieldNumber = 10,
    kParkingSpaceOverlapInfoFieldNumber = 11,
    kPncJunctionOverlapInfoFieldNumber = 12,
    kRsuOverlapInfoFieldNumber = 13,
  };
  // optional .apollo.hdmap.Id id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::apollo::hdmap::Id& id() const;
  ::apollo::hdmap::Id* release_id();
  ::apollo::hdmap::Id* mutable_id();
  void set_allocated_id(::apollo::hdmap::Id* id);
  private:
  const ::apollo::hdmap::Id& _internal_id() const;
  ::apollo::hdmap::Id* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::apollo::hdmap::Id* id);
  ::apollo::hdmap::Id* unsafe_arena_release_id();

  // .apollo.hdmap.LaneOverlapInfo lane_overlap_info = 3;
  bool has_lane_overlap_info() const;
  private:
  bool _internal_has_lane_overlap_info() const;
  public:
  void clear_lane_overlap_info();
  const ::apollo::hdmap::LaneOverlapInfo& lane_overlap_info() const;
  ::apollo::hdmap::LaneOverlapInfo* release_lane_overlap_info();
  ::apollo::hdmap::LaneOverlapInfo* mutable_lane_overlap_info();
  void set_allocated_lane_overlap_info(::apollo::hdmap::LaneOverlapInfo* lane_overlap_info);
  private:
  const ::apollo::hdmap::LaneOverlapInfo& _internal_lane_overlap_info() const;
  ::apollo::hdmap::LaneOverlapInfo* _internal_mutable_lane_overlap_info();
  public:
  void unsafe_arena_set_allocated_lane_overlap_info(
      ::apollo::hdmap::LaneOverlapInfo* lane_overlap_info);
  ::apollo::hdmap::LaneOverlapInfo* unsafe_arena_release_lane_overlap_info();

  // .apollo.hdmap.SignalOverlapInfo signal_overlap_info = 4;
  bool has_signal_overlap_info() const;
  private:
  bool _internal_has_signal_overlap_info() const;
  public:
  void clear_signal_overlap_info();
  const ::apollo::hdmap::SignalOverlapInfo& signal_overlap_info() const;
  ::apollo::hdmap::SignalOverlapInfo* release_signal_overlap_info();
  ::apollo::hdmap::SignalOverlapInfo* mutable_signal_overlap_info();
  void set_allocated_signal_overlap_info(::apollo::hdmap::SignalOverlapInfo* signal_overlap_info);
  private:
  const ::apollo::hdmap::SignalOverlapInfo& _internal_signal_overlap_info() const;
  ::apollo::hdmap::SignalOverlapInfo* _internal_mutable_signal_overlap_info();
  public:
  void unsafe_arena_set_allocated_signal_overlap_info(
      ::apollo::hdmap::SignalOverlapInfo* signal_overlap_info);
  ::apollo::hdmap::SignalOverlapInfo* unsafe_arena_release_signal_overlap_info();

  // .apollo.hdmap.StopSignOverlapInfo stop_sign_overlap_info = 5;
  bool has_stop_sign_overlap_info() const;
  private:
  bool _internal_has_stop_sign_overlap_info() const;
  public:
  void clear_stop_sign_overlap_info();
  const ::apollo::hdmap::StopSignOverlapInfo& stop_sign_overlap_info() const;
  ::apollo::hdmap::StopSignOverlapInfo* release_stop_sign_overlap_info();
  ::apollo::hdmap::StopSignOverlapInfo* mutable_stop_sign_overlap_info();
  void set_allocated_stop_sign_overlap_info(::apollo::hdmap::StopSignOverlapInfo* stop_sign_overlap_info);
  private:
  const ::apollo::hdmap::StopSignOverlapInfo& _internal_stop_sign_overlap_info() const;
  ::apollo::hdmap::StopSignOverlapInfo* _internal_mutable_stop_sign_overlap_info();
  public:
  void unsafe_arena_set_allocated_stop_sign_overlap_info(
      ::apollo::hdmap::StopSignOverlapInfo* stop_sign_overlap_info);
  ::apollo::hdmap::StopSignOverlapInfo* unsafe_arena_release_stop_sign_overlap_info();

  // .apollo.hdmap.CrosswalkOverlapInfo crosswalk_overlap_info = 6;
  bool has_crosswalk_overlap_info() const;
  private:
  bool _internal_has_crosswalk_overlap_info() const;
  public:
  void clear_crosswalk_overlap_info();
  const ::apollo::hdmap::CrosswalkOverlapInfo& crosswalk_overlap_info() const;
  ::apollo::hdmap::CrosswalkOverlapInfo* release_crosswalk_overlap_info();
  ::apollo::hdmap::CrosswalkOverlapInfo* mutable_crosswalk_overlap_info();
  void set_allocated_crosswalk_overlap_info(::apollo::hdmap::CrosswalkOverlapInfo* crosswalk_overlap_info);
  private:
  const ::apollo::hdmap::CrosswalkOverlapInfo& _internal_crosswalk_overlap_info() const;
  ::apollo::hdmap::CrosswalkOverlapInfo* _internal_mutable_crosswalk_overlap_info();
  public:
  void unsafe_arena_set_allocated_crosswalk_overlap_info(
      ::apollo::hdmap::CrosswalkOverlapInfo* crosswalk_overlap_info);
  ::apollo::hdmap::CrosswalkOverlapInfo* unsafe_arena_release_crosswalk_overlap_info();

  // .apollo.hdmap.JunctionOverlapInfo junction_overlap_info = 7;
  bool has_junction_overlap_info() const;
  private:
  bool _internal_has_junction_overlap_info() const;
  public:
  void clear_junction_overlap_info();
  const ::apollo::hdmap::JunctionOverlapInfo& junction_overlap_info() const;
  ::apollo::hdmap::JunctionOverlapInfo* release_junction_overlap_info();
  ::apollo::hdmap::JunctionOverlapInfo* mutable_junction_overlap_info();
  void set_allocated_junction_overlap_info(::apollo::hdmap::JunctionOverlapInfo* junction_overlap_info);
  private:
  const ::apollo::hdmap::JunctionOverlapInfo& _internal_junction_overlap_info() const;
  ::apollo::hdmap::JunctionOverlapInfo* _internal_mutable_junction_overlap_info();
  public:
  void unsafe_arena_set_allocated_junction_overlap_info(
      ::apollo::hdmap::JunctionOverlapInfo* junction_overlap_info);
  ::apollo::hdmap::JunctionOverlapInfo* unsafe_arena_release_junction_overlap_info();

  // .apollo.hdmap.YieldOverlapInfo yield_sign_overlap_info = 8;
  bool has_yield_sign_overlap_info() const;
  private:
  bool _internal_has_yield_sign_overlap_info() const;
  public:
  void clear_yield_sign_overlap_info();
  const ::apollo::hdmap::YieldOverlapInfo& yield_sign_overlap_info() const;
  ::apollo::hdmap::YieldOverlapInfo* release_yield_sign_overlap_info();
  ::apollo::hdmap::YieldOverlapInfo* mutable_yield_sign_overlap_info();
  void set_allocated_yield_sign_overlap_info(::apollo::hdmap::YieldOverlapInfo* yield_sign_overlap_info);
  private:
  const ::apollo::hdmap::YieldOverlapInfo& _internal_yield_sign_overlap_info() const;
  ::apollo::hdmap::YieldOverlapInfo* _internal_mutable_yield_sign_overlap_info();
  public:
  void unsafe_arena_set_allocated_yield_sign_overlap_info(
      ::apollo::hdmap::YieldOverlapInfo* yield_sign_overlap_info);
  ::apollo::hdmap::YieldOverlapInfo* unsafe_arena_release_yield_sign_overlap_info();

  // .apollo.hdmap.ClearAreaOverlapInfo clear_area_overlap_info = 9;
  bool has_clear_area_overlap_info() const;
  private:
  bool _internal_has_clear_area_overlap_info() const;
  public:
  void clear_clear_area_overlap_info();
  const ::apollo::hdmap::ClearAreaOverlapInfo& clear_area_overlap_info() const;
  ::apollo::hdmap::ClearAreaOverlapInfo* release_clear_area_overlap_info();
  ::apollo::hdmap::ClearAreaOverlapInfo* mutable_clear_area_overlap_info();
  void set_allocated_clear_area_overlap_info(::apollo::hdmap::ClearAreaOverlapInfo* clear_area_overlap_info);
  private:
  const ::apollo::hdmap::ClearAreaOverlapInfo& _internal_clear_area_overlap_info() const;
  ::apollo::hdmap::ClearAreaOverlapInfo* _internal_mutable_clear_area_overlap_info();
  public:
  void unsafe_arena_set_allocated_clear_area_overlap_info(
      ::apollo::hdmap::ClearAreaOverlapInfo* clear_area_overlap_info);
  ::apollo::hdmap::ClearAreaOverlapInfo* unsafe_arena_release_clear_area_overlap_info();

  // .apollo.hdmap.SpeedBumpOverlapInfo speed_bump_overlap_info = 10;
  bool has_speed_bump_overlap_info() const;
  private:
  bool _internal_has_speed_bump_overlap_info() const;
  public:
  void clear_speed_bump_overlap_info();
  const ::apollo::hdmap::SpeedBumpOverlapInfo& speed_bump_overlap_info() const;
  ::apollo::hdmap::SpeedBumpOverlapInfo* release_speed_bump_overlap_info();
  ::apollo::hdmap::SpeedBumpOverlapInfo* mutable_speed_bump_overlap_info();
  void set_allocated_speed_bump_overlap_info(::apollo::hdmap::SpeedBumpOverlapInfo* speed_bump_overlap_info);
  private:
  const ::apollo::hdmap::SpeedBumpOverlapInfo& _internal_speed_bump_overlap_info() const;
  ::apollo::hdmap::SpeedBumpOverlapInfo* _internal_mutable_speed_bump_overlap_info();
  public:
  void unsafe_arena_set_allocated_speed_bump_overlap_info(
      ::apollo::hdmap::SpeedBumpOverlapInfo* speed_bump_overlap_info);
  ::apollo::hdmap::SpeedBumpOverlapInfo* unsafe_arena_release_speed_bump_overlap_info();

  // .apollo.hdmap.ParkingSpaceOverlapInfo parking_space_overlap_info = 11;
  bool has_parking_space_overlap_info() const;
  private:
  bool _internal_has_parking_space_overlap_info() const;
  public:
  void clear_parking_space_overlap_info();
  const ::apollo::hdmap::ParkingSpaceOverlapInfo& parking_space_overlap_info() const;
  ::apollo::hdmap::ParkingSpaceOverlapInfo* release_parking_space_overlap_info();
  ::apollo::hdmap::ParkingSpaceOverlapInfo* mutable_parking_space_overlap_info();
  void set_allocated_parking_space_overlap_info(::apollo::hdmap::ParkingSpaceOverlapInfo* parking_space_overlap_info);
  private:
  const ::apollo::hdmap::ParkingSpaceOverlapInfo& _internal_parking_space_overlap_info() const;
  ::apollo::hdmap::ParkingSpaceOverlapInfo* _internal_mutable_parking_space_overlap_info();
  public:
  void unsafe_arena_set_allocated_parking_space_overlap_info(
      ::apollo::hdmap::ParkingSpaceOverlapInfo* parking_space_overlap_info);
  ::apollo::hdmap::ParkingSpaceOverlapInfo* unsafe_arena_release_parking_space_overlap_info();

  // .apollo.hdmap.PNCJunctionOverlapInfo pnc_junction_overlap_info = 12;
  bool has_pnc_junction_overlap_info() const;
  private:
  bool _internal_has_pnc_junction_overlap_info() const;
  public:
  void clear_pnc_junction_overlap_info();
  const ::apollo::hdmap::PNCJunctionOverlapInfo& pnc_junction_overlap_info() const;
  ::apollo::hdmap::PNCJunctionOverlapInfo* release_pnc_junction_overlap_info();
  ::apollo::hdmap::PNCJunctionOverlapInfo* mutable_pnc_junction_overlap_info();
  void set_allocated_pnc_junction_overlap_info(::apollo::hdmap::PNCJunctionOverlapInfo* pnc_junction_overlap_info);
  private:
  const ::apollo::hdmap::PNCJunctionOverlapInfo& _internal_pnc_junction_overlap_info() const;
  ::apollo::hdmap::PNCJunctionOverlapInfo* _internal_mutable_pnc_junction_overlap_info();
  public:
  void unsafe_arena_set_allocated_pnc_junction_overlap_info(
      ::apollo::hdmap::PNCJunctionOverlapInfo* pnc_junction_overlap_info);
  ::apollo::hdmap::PNCJunctionOverlapInfo* unsafe_arena_release_pnc_junction_overlap_info();

  // .apollo.hdmap.RSUOverlapInfo rsu_overlap_info = 13;
  bool has_rsu_overlap_info() const;
  private:
  bool _internal_has_rsu_overlap_info() const;
  public:
  void clear_rsu_overlap_info();
  const ::apollo::hdmap::RSUOverlapInfo& rsu_overlap_info() const;
  ::apollo::hdmap::RSUOverlapInfo* release_rsu_overlap_info();
  ::apollo::hdmap::RSUOverlapInfo* mutable_rsu_overlap_info();
  void set_allocated_rsu_overlap_info(::apollo::hdmap::RSUOverlapInfo* rsu_overlap_info);
  private:
  const ::apollo::hdmap::RSUOverlapInfo& _internal_rsu_overlap_info() const;
  ::apollo::hdmap::RSUOverlapInfo* _internal_mutable_rsu_overlap_info();
  public:
  void unsafe_arena_set_allocated_rsu_overlap_info(
      ::apollo::hdmap::RSUOverlapInfo* rsu_overlap_info);
  ::apollo::hdmap::RSUOverlapInfo* unsafe_arena_release_rsu_overlap_info();

  void clear_overlap_info();
  OverlapInfoCase overlap_info_case() const;
  // @@protoc_insertion_point(class_scope:apollo.hdmap.ObjectOverlapInfo)
 private:
  class _Internal;
  void set_has_lane_overlap_info();
  void set_has_signal_overlap_info();
  void set_has_stop_sign_overlap_info();
  void set_has_crosswalk_overlap_info();
  void set_has_junction_overlap_info();
  void set_has_yield_sign_overlap_info();
  void set_has_clear_area_overlap_info();
  void set_has_speed_bump_overlap_info();
  void set_has_parking_space_overlap_info();
  void set_has_pnc_junction_overlap_info();
  void set_has_rsu_overlap_info();

  inline bool has_overlap_info() const;
  inline void clear_has_overlap_info();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::apollo::hdmap::Id* id_;
  union OverlapInfoUnion {
    OverlapInfoUnion() {}
    ::apollo::hdmap::LaneOverlapInfo* lane_overlap_info_;
    ::apollo::hdmap::SignalOverlapInfo* signal_overlap_info_;
    ::apollo::hdmap::StopSignOverlapInfo* stop_sign_overlap_info_;
    ::apollo::hdmap::CrosswalkOverlapInfo* crosswalk_overlap_info_;
    ::apollo::hdmap::JunctionOverlapInfo* junction_overlap_info_;
    ::apollo::hdmap::YieldOverlapInfo* yield_sign_overlap_info_;
    ::apollo::hdmap::ClearAreaOverlapInfo* clear_area_overlap_info_;
    ::apollo::hdmap::SpeedBumpOverlapInfo* speed_bump_overlap_info_;
    ::apollo::hdmap::ParkingSpaceOverlapInfo* parking_space_overlap_info_;
    ::apollo::hdmap::PNCJunctionOverlapInfo* pnc_junction_overlap_info_;
    ::apollo::hdmap::RSUOverlapInfo* rsu_overlap_info_;
  } overlap_info_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_modules_2fmap_2fproto_2fmap_5foverlap_2eproto;
};
// -------------------------------------------------------------------

class Overlap PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apollo.hdmap.Overlap) */ {
 public:
  inline Overlap() : Overlap(nullptr) {}
  virtual ~Overlap();

  Overlap(const Overlap& from);
  Overlap(Overlap&& from) noexcept
    : Overlap() {
    *this = ::std::move(from);
  }

  inline Overlap& operator=(const Overlap& from) {
    CopyFrom(from);
    return *this;
  }
  inline Overlap& operator=(Overlap&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Overlap& default_instance();

  static inline const Overlap* internal_default_instance() {
    return reinterpret_cast<const Overlap*>(
               &_Overlap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Overlap& a, Overlap& b) {
    a.Swap(&b);
  }
  inline void Swap(Overlap* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Overlap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Overlap* New() const final {
    return CreateMaybeMessage<Overlap>(nullptr);
  }

  Overlap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Overlap>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Overlap& from);
  void MergeFrom(const Overlap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Overlap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apollo.hdmap.Overlap";
  }
  protected:
  explicit Overlap(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto);
    return ::descriptor_table_modules_2fmap_2fproto_2fmap_5foverlap_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectFieldNumber = 2,
    kRegionOverlapFieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // repeated .apollo.hdmap.ObjectOverlapInfo object = 2;
  int object_size() const;
  private:
  int _internal_object_size() const;
  public:
  void clear_object();
  ::apollo::hdmap::ObjectOverlapInfo* mutable_object(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::hdmap::ObjectOverlapInfo >*
      mutable_object();
  private:
  const ::apollo::hdmap::ObjectOverlapInfo& _internal_object(int index) const;
  ::apollo::hdmap::ObjectOverlapInfo* _internal_add_object();
  public:
  const ::apollo::hdmap::ObjectOverlapInfo& object(int index) const;
  ::apollo::hdmap::ObjectOverlapInfo* add_object();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::hdmap::ObjectOverlapInfo >&
      object() const;

  // repeated .apollo.hdmap.RegionOverlapInfo region_overlap = 3;
  int region_overlap_size() const;
  private:
  int _internal_region_overlap_size() const;
  public:
  void clear_region_overlap();
  ::apollo::hdmap::RegionOverlapInfo* mutable_region_overlap(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::hdmap::RegionOverlapInfo >*
      mutable_region_overlap();
  private:
  const ::apollo::hdmap::RegionOverlapInfo& _internal_region_overlap(int index) const;
  ::apollo::hdmap::RegionOverlapInfo* _internal_add_region_overlap();
  public:
  const ::apollo::hdmap::RegionOverlapInfo& region_overlap(int index) const;
  ::apollo::hdmap::RegionOverlapInfo* add_region_overlap();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::hdmap::RegionOverlapInfo >&
      region_overlap() const;

  // optional .apollo.hdmap.Id id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::apollo::hdmap::Id& id() const;
  ::apollo::hdmap::Id* release_id();
  ::apollo::hdmap::Id* mutable_id();
  void set_allocated_id(::apollo::hdmap::Id* id);
  private:
  const ::apollo::hdmap::Id& _internal_id() const;
  ::apollo::hdmap::Id* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::apollo::hdmap::Id* id);
  ::apollo::hdmap::Id* unsafe_arena_release_id();

  // @@protoc_insertion_point(class_scope:apollo.hdmap.Overlap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::hdmap::ObjectOverlapInfo > object_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::hdmap::RegionOverlapInfo > region_overlap_;
  ::apollo::hdmap::Id* id_;
  friend struct ::TableStruct_modules_2fmap_2fproto_2fmap_5foverlap_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LaneOverlapInfo

// optional double start_s = 1;
inline bool LaneOverlapInfo::_internal_has_start_s() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LaneOverlapInfo::has_start_s() const {
  return _internal_has_start_s();
}
inline void LaneOverlapInfo::clear_start_s() {
  start_s_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double LaneOverlapInfo::_internal_start_s() const {
  return start_s_;
}
inline double LaneOverlapInfo::start_s() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.LaneOverlapInfo.start_s)
  return _internal_start_s();
}
inline void LaneOverlapInfo::_internal_set_start_s(double value) {
  _has_bits_[0] |= 0x00000002u;
  start_s_ = value;
}
inline void LaneOverlapInfo::set_start_s(double value) {
  _internal_set_start_s(value);
  // @@protoc_insertion_point(field_set:apollo.hdmap.LaneOverlapInfo.start_s)
}

// optional double end_s = 2;
inline bool LaneOverlapInfo::_internal_has_end_s() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LaneOverlapInfo::has_end_s() const {
  return _internal_has_end_s();
}
inline void LaneOverlapInfo::clear_end_s() {
  end_s_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double LaneOverlapInfo::_internal_end_s() const {
  return end_s_;
}
inline double LaneOverlapInfo::end_s() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.LaneOverlapInfo.end_s)
  return _internal_end_s();
}
inline void LaneOverlapInfo::_internal_set_end_s(double value) {
  _has_bits_[0] |= 0x00000004u;
  end_s_ = value;
}
inline void LaneOverlapInfo::set_end_s(double value) {
  _internal_set_end_s(value);
  // @@protoc_insertion_point(field_set:apollo.hdmap.LaneOverlapInfo.end_s)
}

// optional bool is_merge = 3;
inline bool LaneOverlapInfo::_internal_has_is_merge() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LaneOverlapInfo::has_is_merge() const {
  return _internal_has_is_merge();
}
inline void LaneOverlapInfo::clear_is_merge() {
  is_merge_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool LaneOverlapInfo::_internal_is_merge() const {
  return is_merge_;
}
inline bool LaneOverlapInfo::is_merge() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.LaneOverlapInfo.is_merge)
  return _internal_is_merge();
}
inline void LaneOverlapInfo::_internal_set_is_merge(bool value) {
  _has_bits_[0] |= 0x00000008u;
  is_merge_ = value;
}
inline void LaneOverlapInfo::set_is_merge(bool value) {
  _internal_set_is_merge(value);
  // @@protoc_insertion_point(field_set:apollo.hdmap.LaneOverlapInfo.is_merge)
}

// optional .apollo.hdmap.Id region_overlap_id = 4;
inline bool LaneOverlapInfo::_internal_has_region_overlap_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || region_overlap_id_ != nullptr);
  return value;
}
inline bool LaneOverlapInfo::has_region_overlap_id() const {
  return _internal_has_region_overlap_id();
}
inline const ::apollo::hdmap::Id& LaneOverlapInfo::_internal_region_overlap_id() const {
  const ::apollo::hdmap::Id* p = region_overlap_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::hdmap::Id&>(
      ::apollo::hdmap::_Id_default_instance_);
}
inline const ::apollo::hdmap::Id& LaneOverlapInfo::region_overlap_id() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.LaneOverlapInfo.region_overlap_id)
  return _internal_region_overlap_id();
}
inline void LaneOverlapInfo::unsafe_arena_set_allocated_region_overlap_id(
    ::apollo::hdmap::Id* region_overlap_id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_overlap_id_);
  }
  region_overlap_id_ = region_overlap_id;
  if (region_overlap_id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.hdmap.LaneOverlapInfo.region_overlap_id)
}
inline ::apollo::hdmap::Id* LaneOverlapInfo::release_region_overlap_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::apollo::hdmap::Id* temp = region_overlap_id_;
  region_overlap_id_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::apollo::hdmap::Id* LaneOverlapInfo::unsafe_arena_release_region_overlap_id() {
  // @@protoc_insertion_point(field_release:apollo.hdmap.LaneOverlapInfo.region_overlap_id)
  _has_bits_[0] &= ~0x00000001u;
  ::apollo::hdmap::Id* temp = region_overlap_id_;
  region_overlap_id_ = nullptr;
  return temp;
}
inline ::apollo::hdmap::Id* LaneOverlapInfo::_internal_mutable_region_overlap_id() {
  _has_bits_[0] |= 0x00000001u;
  if (region_overlap_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::hdmap::Id>(GetArena());
    region_overlap_id_ = p;
  }
  return region_overlap_id_;
}
inline ::apollo::hdmap::Id* LaneOverlapInfo::mutable_region_overlap_id() {
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.LaneOverlapInfo.region_overlap_id)
  return _internal_mutable_region_overlap_id();
}
inline void LaneOverlapInfo::set_allocated_region_overlap_id(::apollo::hdmap::Id* region_overlap_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_overlap_id_);
  }
  if (region_overlap_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_overlap_id)->GetArena();
    if (message_arena != submessage_arena) {
      region_overlap_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region_overlap_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  region_overlap_id_ = region_overlap_id;
  // @@protoc_insertion_point(field_set_allocated:apollo.hdmap.LaneOverlapInfo.region_overlap_id)
}

// -------------------------------------------------------------------

// SignalOverlapInfo

// -------------------------------------------------------------------

// StopSignOverlapInfo

// -------------------------------------------------------------------

// CrosswalkOverlapInfo

// optional .apollo.hdmap.Id region_overlap_id = 1;
inline bool CrosswalkOverlapInfo::_internal_has_region_overlap_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || region_overlap_id_ != nullptr);
  return value;
}
inline bool CrosswalkOverlapInfo::has_region_overlap_id() const {
  return _internal_has_region_overlap_id();
}
inline const ::apollo::hdmap::Id& CrosswalkOverlapInfo::_internal_region_overlap_id() const {
  const ::apollo::hdmap::Id* p = region_overlap_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::hdmap::Id&>(
      ::apollo::hdmap::_Id_default_instance_);
}
inline const ::apollo::hdmap::Id& CrosswalkOverlapInfo::region_overlap_id() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.CrosswalkOverlapInfo.region_overlap_id)
  return _internal_region_overlap_id();
}
inline void CrosswalkOverlapInfo::unsafe_arena_set_allocated_region_overlap_id(
    ::apollo::hdmap::Id* region_overlap_id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_overlap_id_);
  }
  region_overlap_id_ = region_overlap_id;
  if (region_overlap_id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.hdmap.CrosswalkOverlapInfo.region_overlap_id)
}
inline ::apollo::hdmap::Id* CrosswalkOverlapInfo::release_region_overlap_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::apollo::hdmap::Id* temp = region_overlap_id_;
  region_overlap_id_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::apollo::hdmap::Id* CrosswalkOverlapInfo::unsafe_arena_release_region_overlap_id() {
  // @@protoc_insertion_point(field_release:apollo.hdmap.CrosswalkOverlapInfo.region_overlap_id)
  _has_bits_[0] &= ~0x00000001u;
  ::apollo::hdmap::Id* temp = region_overlap_id_;
  region_overlap_id_ = nullptr;
  return temp;
}
inline ::apollo::hdmap::Id* CrosswalkOverlapInfo::_internal_mutable_region_overlap_id() {
  _has_bits_[0] |= 0x00000001u;
  if (region_overlap_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::hdmap::Id>(GetArena());
    region_overlap_id_ = p;
  }
  return region_overlap_id_;
}
inline ::apollo::hdmap::Id* CrosswalkOverlapInfo::mutable_region_overlap_id() {
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.CrosswalkOverlapInfo.region_overlap_id)
  return _internal_mutable_region_overlap_id();
}
inline void CrosswalkOverlapInfo::set_allocated_region_overlap_id(::apollo::hdmap::Id* region_overlap_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_overlap_id_);
  }
  if (region_overlap_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_overlap_id)->GetArena();
    if (message_arena != submessage_arena) {
      region_overlap_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region_overlap_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  region_overlap_id_ = region_overlap_id;
  // @@protoc_insertion_point(field_set_allocated:apollo.hdmap.CrosswalkOverlapInfo.region_overlap_id)
}

// -------------------------------------------------------------------

// JunctionOverlapInfo

// -------------------------------------------------------------------

// YieldOverlapInfo

// -------------------------------------------------------------------

// ClearAreaOverlapInfo

// -------------------------------------------------------------------

// SpeedBumpOverlapInfo

// -------------------------------------------------------------------

// ParkingSpaceOverlapInfo

// -------------------------------------------------------------------

// PNCJunctionOverlapInfo

// -------------------------------------------------------------------

// RSUOverlapInfo

// -------------------------------------------------------------------

// RegionOverlapInfo

// optional .apollo.hdmap.Id id = 1;
inline bool RegionOverlapInfo::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || id_ != nullptr);
  return value;
}
inline bool RegionOverlapInfo::has_id() const {
  return _internal_has_id();
}
inline const ::apollo::hdmap::Id& RegionOverlapInfo::_internal_id() const {
  const ::apollo::hdmap::Id* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::hdmap::Id&>(
      ::apollo::hdmap::_Id_default_instance_);
}
inline const ::apollo::hdmap::Id& RegionOverlapInfo::id() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.RegionOverlapInfo.id)
  return _internal_id();
}
inline void RegionOverlapInfo::unsafe_arena_set_allocated_id(
    ::apollo::hdmap::Id* id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.hdmap.RegionOverlapInfo.id)
}
inline ::apollo::hdmap::Id* RegionOverlapInfo::release_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::apollo::hdmap::Id* temp = id_;
  id_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::apollo::hdmap::Id* RegionOverlapInfo::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:apollo.hdmap.RegionOverlapInfo.id)
  _has_bits_[0] &= ~0x00000001u;
  ::apollo::hdmap::Id* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::apollo::hdmap::Id* RegionOverlapInfo::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::hdmap::Id>(GetArena());
    id_ = p;
  }
  return id_;
}
inline ::apollo::hdmap::Id* RegionOverlapInfo::mutable_id() {
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.RegionOverlapInfo.id)
  return _internal_mutable_id();
}
inline void RegionOverlapInfo::set_allocated_id(::apollo::hdmap::Id* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id)->GetArena();
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:apollo.hdmap.RegionOverlapInfo.id)
}

// repeated .apollo.hdmap.Polygon polygon = 2;
inline int RegionOverlapInfo::_internal_polygon_size() const {
  return polygon_.size();
}
inline int RegionOverlapInfo::polygon_size() const {
  return _internal_polygon_size();
}
inline ::apollo::hdmap::Polygon* RegionOverlapInfo::mutable_polygon(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.RegionOverlapInfo.polygon)
  return polygon_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::hdmap::Polygon >*
RegionOverlapInfo::mutable_polygon() {
  // @@protoc_insertion_point(field_mutable_list:apollo.hdmap.RegionOverlapInfo.polygon)
  return &polygon_;
}
inline const ::apollo::hdmap::Polygon& RegionOverlapInfo::_internal_polygon(int index) const {
  return polygon_.Get(index);
}
inline const ::apollo::hdmap::Polygon& RegionOverlapInfo::polygon(int index) const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.RegionOverlapInfo.polygon)
  return _internal_polygon(index);
}
inline ::apollo::hdmap::Polygon* RegionOverlapInfo::_internal_add_polygon() {
  return polygon_.Add();
}
inline ::apollo::hdmap::Polygon* RegionOverlapInfo::add_polygon() {
  // @@protoc_insertion_point(field_add:apollo.hdmap.RegionOverlapInfo.polygon)
  return _internal_add_polygon();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::hdmap::Polygon >&
RegionOverlapInfo::polygon() const {
  // @@protoc_insertion_point(field_list:apollo.hdmap.RegionOverlapInfo.polygon)
  return polygon_;
}

// -------------------------------------------------------------------

// ObjectOverlapInfo

// optional .apollo.hdmap.Id id = 1;
inline bool ObjectOverlapInfo::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || id_ != nullptr);
  return value;
}
inline bool ObjectOverlapInfo::has_id() const {
  return _internal_has_id();
}
inline const ::apollo::hdmap::Id& ObjectOverlapInfo::_internal_id() const {
  const ::apollo::hdmap::Id* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::hdmap::Id&>(
      ::apollo::hdmap::_Id_default_instance_);
}
inline const ::apollo::hdmap::Id& ObjectOverlapInfo::id() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.ObjectOverlapInfo.id)
  return _internal_id();
}
inline void ObjectOverlapInfo::unsafe_arena_set_allocated_id(
    ::apollo::hdmap::Id* id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.hdmap.ObjectOverlapInfo.id)
}
inline ::apollo::hdmap::Id* ObjectOverlapInfo::release_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::apollo::hdmap::Id* temp = id_;
  id_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::apollo::hdmap::Id* ObjectOverlapInfo::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:apollo.hdmap.ObjectOverlapInfo.id)
  _has_bits_[0] &= ~0x00000001u;
  ::apollo::hdmap::Id* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::apollo::hdmap::Id* ObjectOverlapInfo::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::hdmap::Id>(GetArena());
    id_ = p;
  }
  return id_;
}
inline ::apollo::hdmap::Id* ObjectOverlapInfo::mutable_id() {
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.ObjectOverlapInfo.id)
  return _internal_mutable_id();
}
inline void ObjectOverlapInfo::set_allocated_id(::apollo::hdmap::Id* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id)->GetArena();
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:apollo.hdmap.ObjectOverlapInfo.id)
}

// .apollo.hdmap.LaneOverlapInfo lane_overlap_info = 3;
inline bool ObjectOverlapInfo::_internal_has_lane_overlap_info() const {
  return overlap_info_case() == kLaneOverlapInfo;
}
inline bool ObjectOverlapInfo::has_lane_overlap_info() const {
  return _internal_has_lane_overlap_info();
}
inline void ObjectOverlapInfo::set_has_lane_overlap_info() {
  _oneof_case_[0] = kLaneOverlapInfo;
}
inline void ObjectOverlapInfo::clear_lane_overlap_info() {
  if (_internal_has_lane_overlap_info()) {
    if (GetArena() == nullptr) {
      delete overlap_info_.lane_overlap_info_;
    }
    clear_has_overlap_info();
  }
}
inline ::apollo::hdmap::LaneOverlapInfo* ObjectOverlapInfo::release_lane_overlap_info() {
  // @@protoc_insertion_point(field_release:apollo.hdmap.ObjectOverlapInfo.lane_overlap_info)
  if (_internal_has_lane_overlap_info()) {
    clear_has_overlap_info();
      ::apollo::hdmap::LaneOverlapInfo* temp = overlap_info_.lane_overlap_info_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    overlap_info_.lane_overlap_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::hdmap::LaneOverlapInfo& ObjectOverlapInfo::_internal_lane_overlap_info() const {
  return _internal_has_lane_overlap_info()
      ? *overlap_info_.lane_overlap_info_
      : reinterpret_cast< ::apollo::hdmap::LaneOverlapInfo&>(::apollo::hdmap::_LaneOverlapInfo_default_instance_);
}
inline const ::apollo::hdmap::LaneOverlapInfo& ObjectOverlapInfo::lane_overlap_info() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.ObjectOverlapInfo.lane_overlap_info)
  return _internal_lane_overlap_info();
}
inline ::apollo::hdmap::LaneOverlapInfo* ObjectOverlapInfo::unsafe_arena_release_lane_overlap_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.hdmap.ObjectOverlapInfo.lane_overlap_info)
  if (_internal_has_lane_overlap_info()) {
    clear_has_overlap_info();
    ::apollo::hdmap::LaneOverlapInfo* temp = overlap_info_.lane_overlap_info_;
    overlap_info_.lane_overlap_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectOverlapInfo::unsafe_arena_set_allocated_lane_overlap_info(::apollo::hdmap::LaneOverlapInfo* lane_overlap_info) {
  clear_overlap_info();
  if (lane_overlap_info) {
    set_has_lane_overlap_info();
    overlap_info_.lane_overlap_info_ = lane_overlap_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.hdmap.ObjectOverlapInfo.lane_overlap_info)
}
inline ::apollo::hdmap::LaneOverlapInfo* ObjectOverlapInfo::_internal_mutable_lane_overlap_info() {
  if (!_internal_has_lane_overlap_info()) {
    clear_overlap_info();
    set_has_lane_overlap_info();
    overlap_info_.lane_overlap_info_ = CreateMaybeMessage< ::apollo::hdmap::LaneOverlapInfo >(GetArena());
  }
  return overlap_info_.lane_overlap_info_;
}
inline ::apollo::hdmap::LaneOverlapInfo* ObjectOverlapInfo::mutable_lane_overlap_info() {
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.ObjectOverlapInfo.lane_overlap_info)
  return _internal_mutable_lane_overlap_info();
}

// .apollo.hdmap.SignalOverlapInfo signal_overlap_info = 4;
inline bool ObjectOverlapInfo::_internal_has_signal_overlap_info() const {
  return overlap_info_case() == kSignalOverlapInfo;
}
inline bool ObjectOverlapInfo::has_signal_overlap_info() const {
  return _internal_has_signal_overlap_info();
}
inline void ObjectOverlapInfo::set_has_signal_overlap_info() {
  _oneof_case_[0] = kSignalOverlapInfo;
}
inline void ObjectOverlapInfo::clear_signal_overlap_info() {
  if (_internal_has_signal_overlap_info()) {
    if (GetArena() == nullptr) {
      delete overlap_info_.signal_overlap_info_;
    }
    clear_has_overlap_info();
  }
}
inline ::apollo::hdmap::SignalOverlapInfo* ObjectOverlapInfo::release_signal_overlap_info() {
  // @@protoc_insertion_point(field_release:apollo.hdmap.ObjectOverlapInfo.signal_overlap_info)
  if (_internal_has_signal_overlap_info()) {
    clear_has_overlap_info();
      ::apollo::hdmap::SignalOverlapInfo* temp = overlap_info_.signal_overlap_info_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    overlap_info_.signal_overlap_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::hdmap::SignalOverlapInfo& ObjectOverlapInfo::_internal_signal_overlap_info() const {
  return _internal_has_signal_overlap_info()
      ? *overlap_info_.signal_overlap_info_
      : reinterpret_cast< ::apollo::hdmap::SignalOverlapInfo&>(::apollo::hdmap::_SignalOverlapInfo_default_instance_);
}
inline const ::apollo::hdmap::SignalOverlapInfo& ObjectOverlapInfo::signal_overlap_info() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.ObjectOverlapInfo.signal_overlap_info)
  return _internal_signal_overlap_info();
}
inline ::apollo::hdmap::SignalOverlapInfo* ObjectOverlapInfo::unsafe_arena_release_signal_overlap_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.hdmap.ObjectOverlapInfo.signal_overlap_info)
  if (_internal_has_signal_overlap_info()) {
    clear_has_overlap_info();
    ::apollo::hdmap::SignalOverlapInfo* temp = overlap_info_.signal_overlap_info_;
    overlap_info_.signal_overlap_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectOverlapInfo::unsafe_arena_set_allocated_signal_overlap_info(::apollo::hdmap::SignalOverlapInfo* signal_overlap_info) {
  clear_overlap_info();
  if (signal_overlap_info) {
    set_has_signal_overlap_info();
    overlap_info_.signal_overlap_info_ = signal_overlap_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.hdmap.ObjectOverlapInfo.signal_overlap_info)
}
inline ::apollo::hdmap::SignalOverlapInfo* ObjectOverlapInfo::_internal_mutable_signal_overlap_info() {
  if (!_internal_has_signal_overlap_info()) {
    clear_overlap_info();
    set_has_signal_overlap_info();
    overlap_info_.signal_overlap_info_ = CreateMaybeMessage< ::apollo::hdmap::SignalOverlapInfo >(GetArena());
  }
  return overlap_info_.signal_overlap_info_;
}
inline ::apollo::hdmap::SignalOverlapInfo* ObjectOverlapInfo::mutable_signal_overlap_info() {
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.ObjectOverlapInfo.signal_overlap_info)
  return _internal_mutable_signal_overlap_info();
}

// .apollo.hdmap.StopSignOverlapInfo stop_sign_overlap_info = 5;
inline bool ObjectOverlapInfo::_internal_has_stop_sign_overlap_info() const {
  return overlap_info_case() == kStopSignOverlapInfo;
}
inline bool ObjectOverlapInfo::has_stop_sign_overlap_info() const {
  return _internal_has_stop_sign_overlap_info();
}
inline void ObjectOverlapInfo::set_has_stop_sign_overlap_info() {
  _oneof_case_[0] = kStopSignOverlapInfo;
}
inline void ObjectOverlapInfo::clear_stop_sign_overlap_info() {
  if (_internal_has_stop_sign_overlap_info()) {
    if (GetArena() == nullptr) {
      delete overlap_info_.stop_sign_overlap_info_;
    }
    clear_has_overlap_info();
  }
}
inline ::apollo::hdmap::StopSignOverlapInfo* ObjectOverlapInfo::release_stop_sign_overlap_info() {
  // @@protoc_insertion_point(field_release:apollo.hdmap.ObjectOverlapInfo.stop_sign_overlap_info)
  if (_internal_has_stop_sign_overlap_info()) {
    clear_has_overlap_info();
      ::apollo::hdmap::StopSignOverlapInfo* temp = overlap_info_.stop_sign_overlap_info_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    overlap_info_.stop_sign_overlap_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::hdmap::StopSignOverlapInfo& ObjectOverlapInfo::_internal_stop_sign_overlap_info() const {
  return _internal_has_stop_sign_overlap_info()
      ? *overlap_info_.stop_sign_overlap_info_
      : reinterpret_cast< ::apollo::hdmap::StopSignOverlapInfo&>(::apollo::hdmap::_StopSignOverlapInfo_default_instance_);
}
inline const ::apollo::hdmap::StopSignOverlapInfo& ObjectOverlapInfo::stop_sign_overlap_info() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.ObjectOverlapInfo.stop_sign_overlap_info)
  return _internal_stop_sign_overlap_info();
}
inline ::apollo::hdmap::StopSignOverlapInfo* ObjectOverlapInfo::unsafe_arena_release_stop_sign_overlap_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.hdmap.ObjectOverlapInfo.stop_sign_overlap_info)
  if (_internal_has_stop_sign_overlap_info()) {
    clear_has_overlap_info();
    ::apollo::hdmap::StopSignOverlapInfo* temp = overlap_info_.stop_sign_overlap_info_;
    overlap_info_.stop_sign_overlap_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectOverlapInfo::unsafe_arena_set_allocated_stop_sign_overlap_info(::apollo::hdmap::StopSignOverlapInfo* stop_sign_overlap_info) {
  clear_overlap_info();
  if (stop_sign_overlap_info) {
    set_has_stop_sign_overlap_info();
    overlap_info_.stop_sign_overlap_info_ = stop_sign_overlap_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.hdmap.ObjectOverlapInfo.stop_sign_overlap_info)
}
inline ::apollo::hdmap::StopSignOverlapInfo* ObjectOverlapInfo::_internal_mutable_stop_sign_overlap_info() {
  if (!_internal_has_stop_sign_overlap_info()) {
    clear_overlap_info();
    set_has_stop_sign_overlap_info();
    overlap_info_.stop_sign_overlap_info_ = CreateMaybeMessage< ::apollo::hdmap::StopSignOverlapInfo >(GetArena());
  }
  return overlap_info_.stop_sign_overlap_info_;
}
inline ::apollo::hdmap::StopSignOverlapInfo* ObjectOverlapInfo::mutable_stop_sign_overlap_info() {
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.ObjectOverlapInfo.stop_sign_overlap_info)
  return _internal_mutable_stop_sign_overlap_info();
}

// .apollo.hdmap.CrosswalkOverlapInfo crosswalk_overlap_info = 6;
inline bool ObjectOverlapInfo::_internal_has_crosswalk_overlap_info() const {
  return overlap_info_case() == kCrosswalkOverlapInfo;
}
inline bool ObjectOverlapInfo::has_crosswalk_overlap_info() const {
  return _internal_has_crosswalk_overlap_info();
}
inline void ObjectOverlapInfo::set_has_crosswalk_overlap_info() {
  _oneof_case_[0] = kCrosswalkOverlapInfo;
}
inline void ObjectOverlapInfo::clear_crosswalk_overlap_info() {
  if (_internal_has_crosswalk_overlap_info()) {
    if (GetArena() == nullptr) {
      delete overlap_info_.crosswalk_overlap_info_;
    }
    clear_has_overlap_info();
  }
}
inline ::apollo::hdmap::CrosswalkOverlapInfo* ObjectOverlapInfo::release_crosswalk_overlap_info() {
  // @@protoc_insertion_point(field_release:apollo.hdmap.ObjectOverlapInfo.crosswalk_overlap_info)
  if (_internal_has_crosswalk_overlap_info()) {
    clear_has_overlap_info();
      ::apollo::hdmap::CrosswalkOverlapInfo* temp = overlap_info_.crosswalk_overlap_info_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    overlap_info_.crosswalk_overlap_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::hdmap::CrosswalkOverlapInfo& ObjectOverlapInfo::_internal_crosswalk_overlap_info() const {
  return _internal_has_crosswalk_overlap_info()
      ? *overlap_info_.crosswalk_overlap_info_
      : reinterpret_cast< ::apollo::hdmap::CrosswalkOverlapInfo&>(::apollo::hdmap::_CrosswalkOverlapInfo_default_instance_);
}
inline const ::apollo::hdmap::CrosswalkOverlapInfo& ObjectOverlapInfo::crosswalk_overlap_info() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.ObjectOverlapInfo.crosswalk_overlap_info)
  return _internal_crosswalk_overlap_info();
}
inline ::apollo::hdmap::CrosswalkOverlapInfo* ObjectOverlapInfo::unsafe_arena_release_crosswalk_overlap_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.hdmap.ObjectOverlapInfo.crosswalk_overlap_info)
  if (_internal_has_crosswalk_overlap_info()) {
    clear_has_overlap_info();
    ::apollo::hdmap::CrosswalkOverlapInfo* temp = overlap_info_.crosswalk_overlap_info_;
    overlap_info_.crosswalk_overlap_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectOverlapInfo::unsafe_arena_set_allocated_crosswalk_overlap_info(::apollo::hdmap::CrosswalkOverlapInfo* crosswalk_overlap_info) {
  clear_overlap_info();
  if (crosswalk_overlap_info) {
    set_has_crosswalk_overlap_info();
    overlap_info_.crosswalk_overlap_info_ = crosswalk_overlap_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.hdmap.ObjectOverlapInfo.crosswalk_overlap_info)
}
inline ::apollo::hdmap::CrosswalkOverlapInfo* ObjectOverlapInfo::_internal_mutable_crosswalk_overlap_info() {
  if (!_internal_has_crosswalk_overlap_info()) {
    clear_overlap_info();
    set_has_crosswalk_overlap_info();
    overlap_info_.crosswalk_overlap_info_ = CreateMaybeMessage< ::apollo::hdmap::CrosswalkOverlapInfo >(GetArena());
  }
  return overlap_info_.crosswalk_overlap_info_;
}
inline ::apollo::hdmap::CrosswalkOverlapInfo* ObjectOverlapInfo::mutable_crosswalk_overlap_info() {
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.ObjectOverlapInfo.crosswalk_overlap_info)
  return _internal_mutable_crosswalk_overlap_info();
}

// .apollo.hdmap.JunctionOverlapInfo junction_overlap_info = 7;
inline bool ObjectOverlapInfo::_internal_has_junction_overlap_info() const {
  return overlap_info_case() == kJunctionOverlapInfo;
}
inline bool ObjectOverlapInfo::has_junction_overlap_info() const {
  return _internal_has_junction_overlap_info();
}
inline void ObjectOverlapInfo::set_has_junction_overlap_info() {
  _oneof_case_[0] = kJunctionOverlapInfo;
}
inline void ObjectOverlapInfo::clear_junction_overlap_info() {
  if (_internal_has_junction_overlap_info()) {
    if (GetArena() == nullptr) {
      delete overlap_info_.junction_overlap_info_;
    }
    clear_has_overlap_info();
  }
}
inline ::apollo::hdmap::JunctionOverlapInfo* ObjectOverlapInfo::release_junction_overlap_info() {
  // @@protoc_insertion_point(field_release:apollo.hdmap.ObjectOverlapInfo.junction_overlap_info)
  if (_internal_has_junction_overlap_info()) {
    clear_has_overlap_info();
      ::apollo::hdmap::JunctionOverlapInfo* temp = overlap_info_.junction_overlap_info_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    overlap_info_.junction_overlap_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::hdmap::JunctionOverlapInfo& ObjectOverlapInfo::_internal_junction_overlap_info() const {
  return _internal_has_junction_overlap_info()
      ? *overlap_info_.junction_overlap_info_
      : reinterpret_cast< ::apollo::hdmap::JunctionOverlapInfo&>(::apollo::hdmap::_JunctionOverlapInfo_default_instance_);
}
inline const ::apollo::hdmap::JunctionOverlapInfo& ObjectOverlapInfo::junction_overlap_info() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.ObjectOverlapInfo.junction_overlap_info)
  return _internal_junction_overlap_info();
}
inline ::apollo::hdmap::JunctionOverlapInfo* ObjectOverlapInfo::unsafe_arena_release_junction_overlap_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.hdmap.ObjectOverlapInfo.junction_overlap_info)
  if (_internal_has_junction_overlap_info()) {
    clear_has_overlap_info();
    ::apollo::hdmap::JunctionOverlapInfo* temp = overlap_info_.junction_overlap_info_;
    overlap_info_.junction_overlap_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectOverlapInfo::unsafe_arena_set_allocated_junction_overlap_info(::apollo::hdmap::JunctionOverlapInfo* junction_overlap_info) {
  clear_overlap_info();
  if (junction_overlap_info) {
    set_has_junction_overlap_info();
    overlap_info_.junction_overlap_info_ = junction_overlap_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.hdmap.ObjectOverlapInfo.junction_overlap_info)
}
inline ::apollo::hdmap::JunctionOverlapInfo* ObjectOverlapInfo::_internal_mutable_junction_overlap_info() {
  if (!_internal_has_junction_overlap_info()) {
    clear_overlap_info();
    set_has_junction_overlap_info();
    overlap_info_.junction_overlap_info_ = CreateMaybeMessage< ::apollo::hdmap::JunctionOverlapInfo >(GetArena());
  }
  return overlap_info_.junction_overlap_info_;
}
inline ::apollo::hdmap::JunctionOverlapInfo* ObjectOverlapInfo::mutable_junction_overlap_info() {
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.ObjectOverlapInfo.junction_overlap_info)
  return _internal_mutable_junction_overlap_info();
}

// .apollo.hdmap.YieldOverlapInfo yield_sign_overlap_info = 8;
inline bool ObjectOverlapInfo::_internal_has_yield_sign_overlap_info() const {
  return overlap_info_case() == kYieldSignOverlapInfo;
}
inline bool ObjectOverlapInfo::has_yield_sign_overlap_info() const {
  return _internal_has_yield_sign_overlap_info();
}
inline void ObjectOverlapInfo::set_has_yield_sign_overlap_info() {
  _oneof_case_[0] = kYieldSignOverlapInfo;
}
inline void ObjectOverlapInfo::clear_yield_sign_overlap_info() {
  if (_internal_has_yield_sign_overlap_info()) {
    if (GetArena() == nullptr) {
      delete overlap_info_.yield_sign_overlap_info_;
    }
    clear_has_overlap_info();
  }
}
inline ::apollo::hdmap::YieldOverlapInfo* ObjectOverlapInfo::release_yield_sign_overlap_info() {
  // @@protoc_insertion_point(field_release:apollo.hdmap.ObjectOverlapInfo.yield_sign_overlap_info)
  if (_internal_has_yield_sign_overlap_info()) {
    clear_has_overlap_info();
      ::apollo::hdmap::YieldOverlapInfo* temp = overlap_info_.yield_sign_overlap_info_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    overlap_info_.yield_sign_overlap_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::hdmap::YieldOverlapInfo& ObjectOverlapInfo::_internal_yield_sign_overlap_info() const {
  return _internal_has_yield_sign_overlap_info()
      ? *overlap_info_.yield_sign_overlap_info_
      : reinterpret_cast< ::apollo::hdmap::YieldOverlapInfo&>(::apollo::hdmap::_YieldOverlapInfo_default_instance_);
}
inline const ::apollo::hdmap::YieldOverlapInfo& ObjectOverlapInfo::yield_sign_overlap_info() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.ObjectOverlapInfo.yield_sign_overlap_info)
  return _internal_yield_sign_overlap_info();
}
inline ::apollo::hdmap::YieldOverlapInfo* ObjectOverlapInfo::unsafe_arena_release_yield_sign_overlap_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.hdmap.ObjectOverlapInfo.yield_sign_overlap_info)
  if (_internal_has_yield_sign_overlap_info()) {
    clear_has_overlap_info();
    ::apollo::hdmap::YieldOverlapInfo* temp = overlap_info_.yield_sign_overlap_info_;
    overlap_info_.yield_sign_overlap_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectOverlapInfo::unsafe_arena_set_allocated_yield_sign_overlap_info(::apollo::hdmap::YieldOverlapInfo* yield_sign_overlap_info) {
  clear_overlap_info();
  if (yield_sign_overlap_info) {
    set_has_yield_sign_overlap_info();
    overlap_info_.yield_sign_overlap_info_ = yield_sign_overlap_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.hdmap.ObjectOverlapInfo.yield_sign_overlap_info)
}
inline ::apollo::hdmap::YieldOverlapInfo* ObjectOverlapInfo::_internal_mutable_yield_sign_overlap_info() {
  if (!_internal_has_yield_sign_overlap_info()) {
    clear_overlap_info();
    set_has_yield_sign_overlap_info();
    overlap_info_.yield_sign_overlap_info_ = CreateMaybeMessage< ::apollo::hdmap::YieldOverlapInfo >(GetArena());
  }
  return overlap_info_.yield_sign_overlap_info_;
}
inline ::apollo::hdmap::YieldOverlapInfo* ObjectOverlapInfo::mutable_yield_sign_overlap_info() {
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.ObjectOverlapInfo.yield_sign_overlap_info)
  return _internal_mutable_yield_sign_overlap_info();
}

// .apollo.hdmap.ClearAreaOverlapInfo clear_area_overlap_info = 9;
inline bool ObjectOverlapInfo::_internal_has_clear_area_overlap_info() const {
  return overlap_info_case() == kClearAreaOverlapInfo;
}
inline bool ObjectOverlapInfo::has_clear_area_overlap_info() const {
  return _internal_has_clear_area_overlap_info();
}
inline void ObjectOverlapInfo::set_has_clear_area_overlap_info() {
  _oneof_case_[0] = kClearAreaOverlapInfo;
}
inline void ObjectOverlapInfo::clear_clear_area_overlap_info() {
  if (_internal_has_clear_area_overlap_info()) {
    if (GetArena() == nullptr) {
      delete overlap_info_.clear_area_overlap_info_;
    }
    clear_has_overlap_info();
  }
}
inline ::apollo::hdmap::ClearAreaOverlapInfo* ObjectOverlapInfo::release_clear_area_overlap_info() {
  // @@protoc_insertion_point(field_release:apollo.hdmap.ObjectOverlapInfo.clear_area_overlap_info)
  if (_internal_has_clear_area_overlap_info()) {
    clear_has_overlap_info();
      ::apollo::hdmap::ClearAreaOverlapInfo* temp = overlap_info_.clear_area_overlap_info_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    overlap_info_.clear_area_overlap_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::hdmap::ClearAreaOverlapInfo& ObjectOverlapInfo::_internal_clear_area_overlap_info() const {
  return _internal_has_clear_area_overlap_info()
      ? *overlap_info_.clear_area_overlap_info_
      : reinterpret_cast< ::apollo::hdmap::ClearAreaOverlapInfo&>(::apollo::hdmap::_ClearAreaOverlapInfo_default_instance_);
}
inline const ::apollo::hdmap::ClearAreaOverlapInfo& ObjectOverlapInfo::clear_area_overlap_info() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.ObjectOverlapInfo.clear_area_overlap_info)
  return _internal_clear_area_overlap_info();
}
inline ::apollo::hdmap::ClearAreaOverlapInfo* ObjectOverlapInfo::unsafe_arena_release_clear_area_overlap_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.hdmap.ObjectOverlapInfo.clear_area_overlap_info)
  if (_internal_has_clear_area_overlap_info()) {
    clear_has_overlap_info();
    ::apollo::hdmap::ClearAreaOverlapInfo* temp = overlap_info_.clear_area_overlap_info_;
    overlap_info_.clear_area_overlap_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectOverlapInfo::unsafe_arena_set_allocated_clear_area_overlap_info(::apollo::hdmap::ClearAreaOverlapInfo* clear_area_overlap_info) {
  clear_overlap_info();
  if (clear_area_overlap_info) {
    set_has_clear_area_overlap_info();
    overlap_info_.clear_area_overlap_info_ = clear_area_overlap_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.hdmap.ObjectOverlapInfo.clear_area_overlap_info)
}
inline ::apollo::hdmap::ClearAreaOverlapInfo* ObjectOverlapInfo::_internal_mutable_clear_area_overlap_info() {
  if (!_internal_has_clear_area_overlap_info()) {
    clear_overlap_info();
    set_has_clear_area_overlap_info();
    overlap_info_.clear_area_overlap_info_ = CreateMaybeMessage< ::apollo::hdmap::ClearAreaOverlapInfo >(GetArena());
  }
  return overlap_info_.clear_area_overlap_info_;
}
inline ::apollo::hdmap::ClearAreaOverlapInfo* ObjectOverlapInfo::mutable_clear_area_overlap_info() {
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.ObjectOverlapInfo.clear_area_overlap_info)
  return _internal_mutable_clear_area_overlap_info();
}

// .apollo.hdmap.SpeedBumpOverlapInfo speed_bump_overlap_info = 10;
inline bool ObjectOverlapInfo::_internal_has_speed_bump_overlap_info() const {
  return overlap_info_case() == kSpeedBumpOverlapInfo;
}
inline bool ObjectOverlapInfo::has_speed_bump_overlap_info() const {
  return _internal_has_speed_bump_overlap_info();
}
inline void ObjectOverlapInfo::set_has_speed_bump_overlap_info() {
  _oneof_case_[0] = kSpeedBumpOverlapInfo;
}
inline void ObjectOverlapInfo::clear_speed_bump_overlap_info() {
  if (_internal_has_speed_bump_overlap_info()) {
    if (GetArena() == nullptr) {
      delete overlap_info_.speed_bump_overlap_info_;
    }
    clear_has_overlap_info();
  }
}
inline ::apollo::hdmap::SpeedBumpOverlapInfo* ObjectOverlapInfo::release_speed_bump_overlap_info() {
  // @@protoc_insertion_point(field_release:apollo.hdmap.ObjectOverlapInfo.speed_bump_overlap_info)
  if (_internal_has_speed_bump_overlap_info()) {
    clear_has_overlap_info();
      ::apollo::hdmap::SpeedBumpOverlapInfo* temp = overlap_info_.speed_bump_overlap_info_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    overlap_info_.speed_bump_overlap_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::hdmap::SpeedBumpOverlapInfo& ObjectOverlapInfo::_internal_speed_bump_overlap_info() const {
  return _internal_has_speed_bump_overlap_info()
      ? *overlap_info_.speed_bump_overlap_info_
      : reinterpret_cast< ::apollo::hdmap::SpeedBumpOverlapInfo&>(::apollo::hdmap::_SpeedBumpOverlapInfo_default_instance_);
}
inline const ::apollo::hdmap::SpeedBumpOverlapInfo& ObjectOverlapInfo::speed_bump_overlap_info() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.ObjectOverlapInfo.speed_bump_overlap_info)
  return _internal_speed_bump_overlap_info();
}
inline ::apollo::hdmap::SpeedBumpOverlapInfo* ObjectOverlapInfo::unsafe_arena_release_speed_bump_overlap_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.hdmap.ObjectOverlapInfo.speed_bump_overlap_info)
  if (_internal_has_speed_bump_overlap_info()) {
    clear_has_overlap_info();
    ::apollo::hdmap::SpeedBumpOverlapInfo* temp = overlap_info_.speed_bump_overlap_info_;
    overlap_info_.speed_bump_overlap_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectOverlapInfo::unsafe_arena_set_allocated_speed_bump_overlap_info(::apollo::hdmap::SpeedBumpOverlapInfo* speed_bump_overlap_info) {
  clear_overlap_info();
  if (speed_bump_overlap_info) {
    set_has_speed_bump_overlap_info();
    overlap_info_.speed_bump_overlap_info_ = speed_bump_overlap_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.hdmap.ObjectOverlapInfo.speed_bump_overlap_info)
}
inline ::apollo::hdmap::SpeedBumpOverlapInfo* ObjectOverlapInfo::_internal_mutable_speed_bump_overlap_info() {
  if (!_internal_has_speed_bump_overlap_info()) {
    clear_overlap_info();
    set_has_speed_bump_overlap_info();
    overlap_info_.speed_bump_overlap_info_ = CreateMaybeMessage< ::apollo::hdmap::SpeedBumpOverlapInfo >(GetArena());
  }
  return overlap_info_.speed_bump_overlap_info_;
}
inline ::apollo::hdmap::SpeedBumpOverlapInfo* ObjectOverlapInfo::mutable_speed_bump_overlap_info() {
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.ObjectOverlapInfo.speed_bump_overlap_info)
  return _internal_mutable_speed_bump_overlap_info();
}

// .apollo.hdmap.ParkingSpaceOverlapInfo parking_space_overlap_info = 11;
inline bool ObjectOverlapInfo::_internal_has_parking_space_overlap_info() const {
  return overlap_info_case() == kParkingSpaceOverlapInfo;
}
inline bool ObjectOverlapInfo::has_parking_space_overlap_info() const {
  return _internal_has_parking_space_overlap_info();
}
inline void ObjectOverlapInfo::set_has_parking_space_overlap_info() {
  _oneof_case_[0] = kParkingSpaceOverlapInfo;
}
inline void ObjectOverlapInfo::clear_parking_space_overlap_info() {
  if (_internal_has_parking_space_overlap_info()) {
    if (GetArena() == nullptr) {
      delete overlap_info_.parking_space_overlap_info_;
    }
    clear_has_overlap_info();
  }
}
inline ::apollo::hdmap::ParkingSpaceOverlapInfo* ObjectOverlapInfo::release_parking_space_overlap_info() {
  // @@protoc_insertion_point(field_release:apollo.hdmap.ObjectOverlapInfo.parking_space_overlap_info)
  if (_internal_has_parking_space_overlap_info()) {
    clear_has_overlap_info();
      ::apollo::hdmap::ParkingSpaceOverlapInfo* temp = overlap_info_.parking_space_overlap_info_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    overlap_info_.parking_space_overlap_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::hdmap::ParkingSpaceOverlapInfo& ObjectOverlapInfo::_internal_parking_space_overlap_info() const {
  return _internal_has_parking_space_overlap_info()
      ? *overlap_info_.parking_space_overlap_info_
      : reinterpret_cast< ::apollo::hdmap::ParkingSpaceOverlapInfo&>(::apollo::hdmap::_ParkingSpaceOverlapInfo_default_instance_);
}
inline const ::apollo::hdmap::ParkingSpaceOverlapInfo& ObjectOverlapInfo::parking_space_overlap_info() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.ObjectOverlapInfo.parking_space_overlap_info)
  return _internal_parking_space_overlap_info();
}
inline ::apollo::hdmap::ParkingSpaceOverlapInfo* ObjectOverlapInfo::unsafe_arena_release_parking_space_overlap_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.hdmap.ObjectOverlapInfo.parking_space_overlap_info)
  if (_internal_has_parking_space_overlap_info()) {
    clear_has_overlap_info();
    ::apollo::hdmap::ParkingSpaceOverlapInfo* temp = overlap_info_.parking_space_overlap_info_;
    overlap_info_.parking_space_overlap_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectOverlapInfo::unsafe_arena_set_allocated_parking_space_overlap_info(::apollo::hdmap::ParkingSpaceOverlapInfo* parking_space_overlap_info) {
  clear_overlap_info();
  if (parking_space_overlap_info) {
    set_has_parking_space_overlap_info();
    overlap_info_.parking_space_overlap_info_ = parking_space_overlap_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.hdmap.ObjectOverlapInfo.parking_space_overlap_info)
}
inline ::apollo::hdmap::ParkingSpaceOverlapInfo* ObjectOverlapInfo::_internal_mutable_parking_space_overlap_info() {
  if (!_internal_has_parking_space_overlap_info()) {
    clear_overlap_info();
    set_has_parking_space_overlap_info();
    overlap_info_.parking_space_overlap_info_ = CreateMaybeMessage< ::apollo::hdmap::ParkingSpaceOverlapInfo >(GetArena());
  }
  return overlap_info_.parking_space_overlap_info_;
}
inline ::apollo::hdmap::ParkingSpaceOverlapInfo* ObjectOverlapInfo::mutable_parking_space_overlap_info() {
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.ObjectOverlapInfo.parking_space_overlap_info)
  return _internal_mutable_parking_space_overlap_info();
}

// .apollo.hdmap.PNCJunctionOverlapInfo pnc_junction_overlap_info = 12;
inline bool ObjectOverlapInfo::_internal_has_pnc_junction_overlap_info() const {
  return overlap_info_case() == kPncJunctionOverlapInfo;
}
inline bool ObjectOverlapInfo::has_pnc_junction_overlap_info() const {
  return _internal_has_pnc_junction_overlap_info();
}
inline void ObjectOverlapInfo::set_has_pnc_junction_overlap_info() {
  _oneof_case_[0] = kPncJunctionOverlapInfo;
}
inline void ObjectOverlapInfo::clear_pnc_junction_overlap_info() {
  if (_internal_has_pnc_junction_overlap_info()) {
    if (GetArena() == nullptr) {
      delete overlap_info_.pnc_junction_overlap_info_;
    }
    clear_has_overlap_info();
  }
}
inline ::apollo::hdmap::PNCJunctionOverlapInfo* ObjectOverlapInfo::release_pnc_junction_overlap_info() {
  // @@protoc_insertion_point(field_release:apollo.hdmap.ObjectOverlapInfo.pnc_junction_overlap_info)
  if (_internal_has_pnc_junction_overlap_info()) {
    clear_has_overlap_info();
      ::apollo::hdmap::PNCJunctionOverlapInfo* temp = overlap_info_.pnc_junction_overlap_info_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    overlap_info_.pnc_junction_overlap_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::hdmap::PNCJunctionOverlapInfo& ObjectOverlapInfo::_internal_pnc_junction_overlap_info() const {
  return _internal_has_pnc_junction_overlap_info()
      ? *overlap_info_.pnc_junction_overlap_info_
      : reinterpret_cast< ::apollo::hdmap::PNCJunctionOverlapInfo&>(::apollo::hdmap::_PNCJunctionOverlapInfo_default_instance_);
}
inline const ::apollo::hdmap::PNCJunctionOverlapInfo& ObjectOverlapInfo::pnc_junction_overlap_info() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.ObjectOverlapInfo.pnc_junction_overlap_info)
  return _internal_pnc_junction_overlap_info();
}
inline ::apollo::hdmap::PNCJunctionOverlapInfo* ObjectOverlapInfo::unsafe_arena_release_pnc_junction_overlap_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.hdmap.ObjectOverlapInfo.pnc_junction_overlap_info)
  if (_internal_has_pnc_junction_overlap_info()) {
    clear_has_overlap_info();
    ::apollo::hdmap::PNCJunctionOverlapInfo* temp = overlap_info_.pnc_junction_overlap_info_;
    overlap_info_.pnc_junction_overlap_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectOverlapInfo::unsafe_arena_set_allocated_pnc_junction_overlap_info(::apollo::hdmap::PNCJunctionOverlapInfo* pnc_junction_overlap_info) {
  clear_overlap_info();
  if (pnc_junction_overlap_info) {
    set_has_pnc_junction_overlap_info();
    overlap_info_.pnc_junction_overlap_info_ = pnc_junction_overlap_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.hdmap.ObjectOverlapInfo.pnc_junction_overlap_info)
}
inline ::apollo::hdmap::PNCJunctionOverlapInfo* ObjectOverlapInfo::_internal_mutable_pnc_junction_overlap_info() {
  if (!_internal_has_pnc_junction_overlap_info()) {
    clear_overlap_info();
    set_has_pnc_junction_overlap_info();
    overlap_info_.pnc_junction_overlap_info_ = CreateMaybeMessage< ::apollo::hdmap::PNCJunctionOverlapInfo >(GetArena());
  }
  return overlap_info_.pnc_junction_overlap_info_;
}
inline ::apollo::hdmap::PNCJunctionOverlapInfo* ObjectOverlapInfo::mutable_pnc_junction_overlap_info() {
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.ObjectOverlapInfo.pnc_junction_overlap_info)
  return _internal_mutable_pnc_junction_overlap_info();
}

// .apollo.hdmap.RSUOverlapInfo rsu_overlap_info = 13;
inline bool ObjectOverlapInfo::_internal_has_rsu_overlap_info() const {
  return overlap_info_case() == kRsuOverlapInfo;
}
inline bool ObjectOverlapInfo::has_rsu_overlap_info() const {
  return _internal_has_rsu_overlap_info();
}
inline void ObjectOverlapInfo::set_has_rsu_overlap_info() {
  _oneof_case_[0] = kRsuOverlapInfo;
}
inline void ObjectOverlapInfo::clear_rsu_overlap_info() {
  if (_internal_has_rsu_overlap_info()) {
    if (GetArena() == nullptr) {
      delete overlap_info_.rsu_overlap_info_;
    }
    clear_has_overlap_info();
  }
}
inline ::apollo::hdmap::RSUOverlapInfo* ObjectOverlapInfo::release_rsu_overlap_info() {
  // @@protoc_insertion_point(field_release:apollo.hdmap.ObjectOverlapInfo.rsu_overlap_info)
  if (_internal_has_rsu_overlap_info()) {
    clear_has_overlap_info();
      ::apollo::hdmap::RSUOverlapInfo* temp = overlap_info_.rsu_overlap_info_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    overlap_info_.rsu_overlap_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::apollo::hdmap::RSUOverlapInfo& ObjectOverlapInfo::_internal_rsu_overlap_info() const {
  return _internal_has_rsu_overlap_info()
      ? *overlap_info_.rsu_overlap_info_
      : reinterpret_cast< ::apollo::hdmap::RSUOverlapInfo&>(::apollo::hdmap::_RSUOverlapInfo_default_instance_);
}
inline const ::apollo::hdmap::RSUOverlapInfo& ObjectOverlapInfo::rsu_overlap_info() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.ObjectOverlapInfo.rsu_overlap_info)
  return _internal_rsu_overlap_info();
}
inline ::apollo::hdmap::RSUOverlapInfo* ObjectOverlapInfo::unsafe_arena_release_rsu_overlap_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:apollo.hdmap.ObjectOverlapInfo.rsu_overlap_info)
  if (_internal_has_rsu_overlap_info()) {
    clear_has_overlap_info();
    ::apollo::hdmap::RSUOverlapInfo* temp = overlap_info_.rsu_overlap_info_;
    overlap_info_.rsu_overlap_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ObjectOverlapInfo::unsafe_arena_set_allocated_rsu_overlap_info(::apollo::hdmap::RSUOverlapInfo* rsu_overlap_info) {
  clear_overlap_info();
  if (rsu_overlap_info) {
    set_has_rsu_overlap_info();
    overlap_info_.rsu_overlap_info_ = rsu_overlap_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.hdmap.ObjectOverlapInfo.rsu_overlap_info)
}
inline ::apollo::hdmap::RSUOverlapInfo* ObjectOverlapInfo::_internal_mutable_rsu_overlap_info() {
  if (!_internal_has_rsu_overlap_info()) {
    clear_overlap_info();
    set_has_rsu_overlap_info();
    overlap_info_.rsu_overlap_info_ = CreateMaybeMessage< ::apollo::hdmap::RSUOverlapInfo >(GetArena());
  }
  return overlap_info_.rsu_overlap_info_;
}
inline ::apollo::hdmap::RSUOverlapInfo* ObjectOverlapInfo::mutable_rsu_overlap_info() {
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.ObjectOverlapInfo.rsu_overlap_info)
  return _internal_mutable_rsu_overlap_info();
}

inline bool ObjectOverlapInfo::has_overlap_info() const {
  return overlap_info_case() != OVERLAP_INFO_NOT_SET;
}
inline void ObjectOverlapInfo::clear_has_overlap_info() {
  _oneof_case_[0] = OVERLAP_INFO_NOT_SET;
}
inline ObjectOverlapInfo::OverlapInfoCase ObjectOverlapInfo::overlap_info_case() const {
  return ObjectOverlapInfo::OverlapInfoCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Overlap

// optional .apollo.hdmap.Id id = 1;
inline bool Overlap::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || id_ != nullptr);
  return value;
}
inline bool Overlap::has_id() const {
  return _internal_has_id();
}
inline const ::apollo::hdmap::Id& Overlap::_internal_id() const {
  const ::apollo::hdmap::Id* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::apollo::hdmap::Id&>(
      ::apollo::hdmap::_Id_default_instance_);
}
inline const ::apollo::hdmap::Id& Overlap::id() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.Overlap.id)
  return _internal_id();
}
inline void Overlap::unsafe_arena_set_allocated_id(
    ::apollo::hdmap::Id* id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apollo.hdmap.Overlap.id)
}
inline ::apollo::hdmap::Id* Overlap::release_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::apollo::hdmap::Id* temp = id_;
  id_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::apollo::hdmap::Id* Overlap::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:apollo.hdmap.Overlap.id)
  _has_bits_[0] &= ~0x00000001u;
  ::apollo::hdmap::Id* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::apollo::hdmap::Id* Overlap::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::apollo::hdmap::Id>(GetArena());
    id_ = p;
  }
  return id_;
}
inline ::apollo::hdmap::Id* Overlap::mutable_id() {
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.Overlap.id)
  return _internal_mutable_id();
}
inline void Overlap::set_allocated_id(::apollo::hdmap::Id* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id)->GetArena();
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:apollo.hdmap.Overlap.id)
}

// repeated .apollo.hdmap.ObjectOverlapInfo object = 2;
inline int Overlap::_internal_object_size() const {
  return object_.size();
}
inline int Overlap::object_size() const {
  return _internal_object_size();
}
inline void Overlap::clear_object() {
  object_.Clear();
}
inline ::apollo::hdmap::ObjectOverlapInfo* Overlap::mutable_object(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.Overlap.object)
  return object_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::hdmap::ObjectOverlapInfo >*
Overlap::mutable_object() {
  // @@protoc_insertion_point(field_mutable_list:apollo.hdmap.Overlap.object)
  return &object_;
}
inline const ::apollo::hdmap::ObjectOverlapInfo& Overlap::_internal_object(int index) const {
  return object_.Get(index);
}
inline const ::apollo::hdmap::ObjectOverlapInfo& Overlap::object(int index) const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.Overlap.object)
  return _internal_object(index);
}
inline ::apollo::hdmap::ObjectOverlapInfo* Overlap::_internal_add_object() {
  return object_.Add();
}
inline ::apollo::hdmap::ObjectOverlapInfo* Overlap::add_object() {
  // @@protoc_insertion_point(field_add:apollo.hdmap.Overlap.object)
  return _internal_add_object();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::hdmap::ObjectOverlapInfo >&
Overlap::object() const {
  // @@protoc_insertion_point(field_list:apollo.hdmap.Overlap.object)
  return object_;
}

// repeated .apollo.hdmap.RegionOverlapInfo region_overlap = 3;
inline int Overlap::_internal_region_overlap_size() const {
  return region_overlap_.size();
}
inline int Overlap::region_overlap_size() const {
  return _internal_region_overlap_size();
}
inline void Overlap::clear_region_overlap() {
  region_overlap_.Clear();
}
inline ::apollo::hdmap::RegionOverlapInfo* Overlap::mutable_region_overlap(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.Overlap.region_overlap)
  return region_overlap_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::hdmap::RegionOverlapInfo >*
Overlap::mutable_region_overlap() {
  // @@protoc_insertion_point(field_mutable_list:apollo.hdmap.Overlap.region_overlap)
  return &region_overlap_;
}
inline const ::apollo::hdmap::RegionOverlapInfo& Overlap::_internal_region_overlap(int index) const {
  return region_overlap_.Get(index);
}
inline const ::apollo::hdmap::RegionOverlapInfo& Overlap::region_overlap(int index) const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.Overlap.region_overlap)
  return _internal_region_overlap(index);
}
inline ::apollo::hdmap::RegionOverlapInfo* Overlap::_internal_add_region_overlap() {
  return region_overlap_.Add();
}
inline ::apollo::hdmap::RegionOverlapInfo* Overlap::add_region_overlap() {
  // @@protoc_insertion_point(field_add:apollo.hdmap.Overlap.region_overlap)
  return _internal_add_region_overlap();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apollo::hdmap::RegionOverlapInfo >&
Overlap::region_overlap() const {
  // @@protoc_insertion_point(field_list:apollo.hdmap.Overlap.region_overlap)
  return region_overlap_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace hdmap
}  // namespace apollo

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_modules_2fmap_2fproto_2fmap_5foverlap_2eproto
